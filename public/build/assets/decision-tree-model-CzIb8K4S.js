var Ze=Object.defineProperty;var Xt=M=>{throw TypeError(M)};var _e=(M,m,d)=>m in M?Ze(M,m,{enumerable:!0,configurable:!0,writable:!0,value:d}):M[m]=d;var dt=(M,m,d)=>_e(M,typeof m!="symbol"?m+"":m,d),Vt=(M,m,d)=>m.has(M)||Xt("Cannot "+d);var nt=(M,m,d)=>(Vt(M,m,"read from private field"),d?d.call(M):m.get(M)),zt=(M,m,d)=>m.has(M)?Xt("Cannot add the same private member more than once"):m instanceof WeakSet?m.add(M):m.set(M,d),Dt=(M,m,d,b)=>(Vt(M,m,"write to private field"),b?b.call(M,d):m.set(M,d),d),Pt=(M,m,d)=>(Vt(M,m,"access private method"),d);import{g as xt,a as xe,b as Lt}from"./app-TSYLOfGo.js";var P={};const Ae=Object.prototype.toString;function Mt(M){const m=Ae.call(M);return m.endsWith("Array]")&&!m.includes("Big")}const He=Object.freeze(Object.defineProperty({__proto__:null,isAnyArray:Mt},Symbol.toStringTag,{value:"Module"})),ts=xt(He);function es(M){var m=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!Mt(M))throw new TypeError("input must be an array");if(M.length===0)throw new TypeError("input must not be empty");var d=m.fromIndex,b=d===void 0?0:d,D=m.toIndex,N=D===void 0?M.length:D;if(b<0||b>=M.length||!Number.isInteger(b))throw new Error("fromIndex must be a positive integer smaller than length");if(N<=b||N>M.length||!Number.isInteger(N))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var F=M[b],$=b+1;$<N;$++)M[$]>F&&(F=M[$]);return F}function ss(M){var m=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(!Mt(M))throw new TypeError("input must be an array");if(M.length===0)throw new TypeError("input must not be empty");var d=m.fromIndex,b=d===void 0?0:d,D=m.toIndex,N=D===void 0?M.length:D;if(b<0||b>=M.length||!Number.isInteger(b))throw new Error("fromIndex must be a positive integer smaller than length");if(N<=b||N>M.length||!Number.isInteger(N))throw new Error("toIndex must be an integer greater than fromIndex and at most equal to length");for(var F=M[b],$=b+1;$<N;$++)M[$]<F&&(F=M[$]);return F}function rs(M){var m=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};if(Mt(M)){if(M.length===0)throw new TypeError("input must not be empty")}else throw new TypeError("input must be an array");var d;if(m.output!==void 0){if(!Mt(m.output))throw new TypeError("output option must be an array if specified");d=m.output}else d=new Array(M.length);var b=ss(M),D=es(M);if(b===D)throw new RangeError("minimum and maximum input values are equal. Cannot rescale a constant array");var N=m.min,F=N===void 0?m.autoMinMax?b:0:N,$=m.max,U=$===void 0?m.autoMinMax?D:1:$;if(F>=U)throw new RangeError("min option must be smaller than max option");for(var K=(U-F)/(D-b),G=0;G<M.length;G++)d[G]=(M[G]-b)*K+F;return d}const os=Object.freeze(Object.defineProperty({__proto__:null,default:rs},Symbol.toStringTag,{value:"Module"})),is=xt(os);var Kt;function ns(){var St,Ot,tt;if(Kt)return P;Kt=1,Object.defineProperty(P,"__esModule",{value:!0});var M=ts,m=is;const d=" ".repeat(2),b=" ".repeat(4);function D(){return N(this)}function N(i,r={}){const{maxRows:e=15,maxColumns:t=10,maxNumSize:s=8,padMinus:o="auto"}=r;return`${i.constructor.name} {
${d}[
${b}${F(i,e,t,s,o)}
${d}]
${d}rows: ${i.rows}
${d}columns: ${i.columns}
}`}function F(i,r,e,t,s){const{rows:o,columns:n}=i,l=Math.min(o,r),h=Math.min(n,e),u=[];if(s==="auto"){s=!1;t:for(let g=0;g<l;g++)for(let f=0;f<h;f++)if(i.get(g,f)<0){s=!0;break t}}for(let g=0;g<l;g++){let f=[];for(let p=0;p<h;p++)f.push($(i.get(g,p),t,s));u.push(`${f.join(" ")}`)}return h!==n&&(u[u.length-1]+=` ... ${n-e} more columns`),l!==o&&u.push(`... ${o-r} more rows`),u.join(`
${b}`)}function $(i,r,e){return(i>=0&&e?` ${U(i,r-1)}`:U(i,r)).padEnd(r)}function U(i,r){let e=i.toString();if(e.length<=r)return e;let t=i.toFixed(r);if(t.length>r&&(t=i.toFixed(Math.max(0,r-(t.length-r)))),t.length<=r&&!t.startsWith("0.000")&&!t.startsWith("-0.000"))return t;let s=i.toExponential(r);return s.length>r&&(s=i.toExponential(Math.max(0,r-(s.length-r)))),s.slice(0)}function K(i,r){i.prototype.add=function(t){return typeof t=="number"?this.addS(t):this.addM(t)},i.prototype.addS=function(t){for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)+t);return this},i.prototype.addM=function(t){if(t=r.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)+t.get(s,o));return this},i.add=function(t,s){return new r(t).add(s)},i.prototype.sub=function(t){return typeof t=="number"?this.subS(t):this.subM(t)},i.prototype.subS=function(t){for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)-t);return this},i.prototype.subM=function(t){if(t=r.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)-t.get(s,o));return this},i.sub=function(t,s){return new r(t).sub(s)},i.prototype.subtract=i.prototype.sub,i.prototype.subtractS=i.prototype.subS,i.prototype.subtractM=i.prototype.subM,i.subtract=i.sub,i.prototype.mul=function(t){return typeof t=="number"?this.mulS(t):this.mulM(t)},i.prototype.mulS=function(t){for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)*t);return this},i.prototype.mulM=function(t){if(t=r.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)*t.get(s,o));return this},i.mul=function(t,s){return new r(t).mul(s)},i.prototype.multiply=i.prototype.mul,i.prototype.multiplyS=i.prototype.mulS,i.prototype.multiplyM=i.prototype.mulM,i.multiply=i.mul,i.prototype.div=function(t){return typeof t=="number"?this.divS(t):this.divM(t)},i.prototype.divS=function(t){for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)/t);return this},i.prototype.divM=function(t){if(t=r.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)/t.get(s,o));return this},i.div=function(t,s){return new r(t).div(s)},i.prototype.divide=i.prototype.div,i.prototype.divideS=i.prototype.divS,i.prototype.divideM=i.prototype.divM,i.divide=i.div,i.prototype.mod=function(t){return typeof t=="number"?this.modS(t):this.modM(t)},i.prototype.modS=function(t){for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)%t);return this},i.prototype.modM=function(t){if(t=r.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)%t.get(s,o));return this},i.mod=function(t,s){return new r(t).mod(s)},i.prototype.modulus=i.prototype.mod,i.prototype.modulusS=i.prototype.modS,i.prototype.modulusM=i.prototype.modM,i.modulus=i.mod,i.prototype.and=function(t){return typeof t=="number"?this.andS(t):this.andM(t)},i.prototype.andS=function(t){for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)&t);return this},i.prototype.andM=function(t){if(t=r.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)&t.get(s,o));return this},i.and=function(t,s){return new r(t).and(s)},i.prototype.or=function(t){return typeof t=="number"?this.orS(t):this.orM(t)},i.prototype.orS=function(t){for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)|t);return this},i.prototype.orM=function(t){if(t=r.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)|t.get(s,o));return this},i.or=function(t,s){return new r(t).or(s)},i.prototype.xor=function(t){return typeof t=="number"?this.xorS(t):this.xorM(t)},i.prototype.xorS=function(t){for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)^t);return this},i.prototype.xorM=function(t){if(t=r.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)^t.get(s,o));return this},i.xor=function(t,s){return new r(t).xor(s)},i.prototype.leftShift=function(t){return typeof t=="number"?this.leftShiftS(t):this.leftShiftM(t)},i.prototype.leftShiftS=function(t){for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)<<t);return this},i.prototype.leftShiftM=function(t){if(t=r.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)<<t.get(s,o));return this},i.leftShift=function(t,s){return new r(t).leftShift(s)},i.prototype.signPropagatingRightShift=function(t){return typeof t=="number"?this.signPropagatingRightShiftS(t):this.signPropagatingRightShiftM(t)},i.prototype.signPropagatingRightShiftS=function(t){for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)>>t);return this},i.prototype.signPropagatingRightShiftM=function(t){if(t=r.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)>>t.get(s,o));return this},i.signPropagatingRightShift=function(t,s){return new r(t).signPropagatingRightShift(s)},i.prototype.rightShift=function(t){return typeof t=="number"?this.rightShiftS(t):this.rightShiftM(t)},i.prototype.rightShiftS=function(t){for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)>>>t);return this},i.prototype.rightShiftM=function(t){if(t=r.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)>>>t.get(s,o));return this},i.rightShift=function(t,s){return new r(t).rightShift(s)},i.prototype.zeroFillRightShift=i.prototype.rightShift,i.prototype.zeroFillRightShiftS=i.prototype.rightShiftS,i.prototype.zeroFillRightShiftM=i.prototype.rightShiftM,i.zeroFillRightShift=i.rightShift,i.prototype.not=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,~this.get(t,s));return this},i.not=function(t){return new r(t).not()},i.prototype.abs=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.abs(this.get(t,s)));return this},i.abs=function(t){return new r(t).abs()},i.prototype.acos=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.acos(this.get(t,s)));return this},i.acos=function(t){return new r(t).acos()},i.prototype.acosh=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.acosh(this.get(t,s)));return this},i.acosh=function(t){return new r(t).acosh()},i.prototype.asin=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.asin(this.get(t,s)));return this},i.asin=function(t){return new r(t).asin()},i.prototype.asinh=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.asinh(this.get(t,s)));return this},i.asinh=function(t){return new r(t).asinh()},i.prototype.atan=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.atan(this.get(t,s)));return this},i.atan=function(t){return new r(t).atan()},i.prototype.atanh=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.atanh(this.get(t,s)));return this},i.atanh=function(t){return new r(t).atanh()},i.prototype.cbrt=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.cbrt(this.get(t,s)));return this},i.cbrt=function(t){return new r(t).cbrt()},i.prototype.ceil=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.ceil(this.get(t,s)));return this},i.ceil=function(t){return new r(t).ceil()},i.prototype.clz32=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.clz32(this.get(t,s)));return this},i.clz32=function(t){return new r(t).clz32()},i.prototype.cos=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.cos(this.get(t,s)));return this},i.cos=function(t){return new r(t).cos()},i.prototype.cosh=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.cosh(this.get(t,s)));return this},i.cosh=function(t){return new r(t).cosh()},i.prototype.exp=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.exp(this.get(t,s)));return this},i.exp=function(t){return new r(t).exp()},i.prototype.expm1=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.expm1(this.get(t,s)));return this},i.expm1=function(t){return new r(t).expm1()},i.prototype.floor=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.floor(this.get(t,s)));return this},i.floor=function(t){return new r(t).floor()},i.prototype.fround=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.fround(this.get(t,s)));return this},i.fround=function(t){return new r(t).fround()},i.prototype.log=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.log(this.get(t,s)));return this},i.log=function(t){return new r(t).log()},i.prototype.log1p=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.log1p(this.get(t,s)));return this},i.log1p=function(t){return new r(t).log1p()},i.prototype.log10=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.log10(this.get(t,s)));return this},i.log10=function(t){return new r(t).log10()},i.prototype.log2=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.log2(this.get(t,s)));return this},i.log2=function(t){return new r(t).log2()},i.prototype.round=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.round(this.get(t,s)));return this},i.round=function(t){return new r(t).round()},i.prototype.sign=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.sign(this.get(t,s)));return this},i.sign=function(t){return new r(t).sign()},i.prototype.sin=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.sin(this.get(t,s)));return this},i.sin=function(t){return new r(t).sin()},i.prototype.sinh=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.sinh(this.get(t,s)));return this},i.sinh=function(t){return new r(t).sinh()},i.prototype.sqrt=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.sqrt(this.get(t,s)));return this},i.sqrt=function(t){return new r(t).sqrt()},i.prototype.tan=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.tan(this.get(t,s)));return this},i.tan=function(t){return new r(t).tan()},i.prototype.tanh=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.tanh(this.get(t,s)));return this},i.tanh=function(t){return new r(t).tanh()},i.prototype.trunc=function(){for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.set(t,s,Math.trunc(this.get(t,s)));return this},i.trunc=function(t){return new r(t).trunc()},i.pow=function(t,s){return new r(t).pow(s)},i.prototype.pow=function(t){return typeof t=="number"?this.powS(t):this.powM(t)},i.prototype.powS=function(t){for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)**t);return this},i.prototype.powM=function(t){if(t=r.checkMatrix(t),this.rows!==t.rows||this.columns!==t.columns)throw new RangeError("Matrices dimensions must be equal");for(let s=0;s<this.rows;s++)for(let o=0;o<this.columns;o++)this.set(s,o,this.get(s,o)**t.get(s,o));return this}}function G(i,r,e){let t=e?i.rows:i.rows-1;if(r<0||r>t)throw new RangeError("Row index out of range")}function Z(i,r,e){let t=e?i.columns:i.columns-1;if(r<0||r>t)throw new RangeError("Column index out of range")}function et(i,r){if(r.to1DArray&&(r=r.to1DArray()),r.length!==i.columns)throw new RangeError("vector size must be the same as the number of columns");return r}function lt(i,r){if(r.to1DArray&&(r=r.to1DArray()),r.length!==i.rows)throw new RangeError("vector size must be the same as the number of rows");return r}function ct(i,r){if(!M.isAnyArray(r))throw new TypeError("row indices must be an array");for(let e=0;e<r.length;e++)if(r[e]<0||r[e]>=i.rows)throw new RangeError("row indices are out of range")}function Ft(i,r){if(!M.isAnyArray(r))throw new TypeError("column indices must be an array");for(let e=0;e<r.length;e++)if(r[e]<0||r[e]>=i.columns)throw new RangeError("column indices are out of range")}function $t(i,r,e,t,s){if(arguments.length!==5)throw new RangeError("expected 4 arguments");if(Et("startRow",r),Et("endRow",e),Et("startColumn",t),Et("endColumn",s),r>e||t>s||r<0||r>=i.rows||e<0||e>=i.rows||t<0||t>=i.columns||s<0||s>=i.columns)throw new RangeError("Submatrix indices are out of range")}function bt(i,r=0){let e=[];for(let t=0;t<i;t++)e.push(r);return e}function Et(i,r){if(typeof r!="number")throw new TypeError(`${i} must be a number`)}function wt(i){if(i.isEmpty())throw new Error("Empty matrix has no elements to index")}function ee(i){let r=bt(i.rows);for(let e=0;e<i.rows;++e)for(let t=0;t<i.columns;++t)r[e]+=i.get(e,t);return r}function se(i){let r=bt(i.columns);for(let e=0;e<i.rows;++e)for(let t=0;t<i.columns;++t)r[t]+=i.get(e,t);return r}function re(i){let r=0;for(let e=0;e<i.rows;e++)for(let t=0;t<i.columns;t++)r+=i.get(e,t);return r}function oe(i){let r=bt(i.rows,1);for(let e=0;e<i.rows;++e)for(let t=0;t<i.columns;++t)r[e]*=i.get(e,t);return r}function ie(i){let r=bt(i.columns,1);for(let e=0;e<i.rows;++e)for(let t=0;t<i.columns;++t)r[t]*=i.get(e,t);return r}function ne(i){let r=1;for(let e=0;e<i.rows;e++)for(let t=0;t<i.columns;t++)r*=i.get(e,t);return r}function le(i,r,e){const t=i.rows,s=i.columns,o=[];for(let n=0;n<t;n++){let l=0,h=0,u=0;for(let g=0;g<s;g++)u=i.get(n,g)-e[n],l+=u,h+=u*u;r?o.push((h-l*l/s)/(s-1)):o.push((h-l*l/s)/s)}return o}function he(i,r,e){const t=i.rows,s=i.columns,o=[];for(let n=0;n<s;n++){let l=0,h=0,u=0;for(let g=0;g<t;g++)u=i.get(g,n)-e[n],l+=u,h+=u*u;r?o.push((h-l*l/t)/(t-1)):o.push((h-l*l/t)/t)}return o}function ue(i,r,e){const t=i.rows,s=i.columns,o=t*s;let n=0,l=0,h=0;for(let u=0;u<t;u++)for(let g=0;g<s;g++)h=i.get(u,g)-e,n+=h,l+=h*h;return r?(l-n*n/o)/(o-1):(l-n*n/o)/o}function fe(i,r){for(let e=0;e<i.rows;e++)for(let t=0;t<i.columns;t++)i.set(e,t,i.get(e,t)-r[e])}function ae(i,r){for(let e=0;e<i.rows;e++)for(let t=0;t<i.columns;t++)i.set(e,t,i.get(e,t)-r[t])}function ce(i,r){for(let e=0;e<i.rows;e++)for(let t=0;t<i.columns;t++)i.set(e,t,i.get(e,t)-r)}function ge(i){const r=[];for(let e=0;e<i.rows;e++){let t=0;for(let s=0;s<i.columns;s++)t+=i.get(e,s)**2/(i.columns-1);r.push(Math.sqrt(t))}return r}function me(i,r){for(let e=0;e<i.rows;e++)for(let t=0;t<i.columns;t++)i.set(e,t,i.get(e,t)/r[e])}function we(i){const r=[];for(let e=0;e<i.columns;e++){let t=0;for(let s=0;s<i.rows;s++)t+=i.get(s,e)**2/(i.rows-1);r.push(Math.sqrt(t))}return r}function pe(i,r){for(let e=0;e<i.rows;e++)for(let t=0;t<i.columns;t++)i.set(e,t,i.get(e,t)/r[t])}function de(i){const r=i.size-1;let e=0;for(let t=0;t<i.columns;t++)for(let s=0;s<i.rows;s++)e+=i.get(s,t)**2/r;return Math.sqrt(e)}function ye(i,r){for(let e=0;e<i.rows;e++)for(let t=0;t<i.columns;t++)i.set(e,t,i.get(e,t)/r)}class z{static from1DArray(r,e,t){if(r*e!==t.length)throw new RangeError("data length does not match given dimensions");let o=new v(r,e);for(let n=0;n<r;n++)for(let l=0;l<e;l++)o.set(n,l,t[n*e+l]);return o}static rowVector(r){let e=new v(1,r.length);for(let t=0;t<r.length;t++)e.set(0,t,r[t]);return e}static columnVector(r){let e=new v(r.length,1);for(let t=0;t<r.length;t++)e.set(t,0,r[t]);return e}static zeros(r,e){return new v(r,e)}static ones(r,e){return new v(r,e).fill(1)}static rand(r,e,t={}){if(typeof t!="object")throw new TypeError("options must be an object");const{random:s=Math.random}=t;let o=new v(r,e);for(let n=0;n<r;n++)for(let l=0;l<e;l++)o.set(n,l,s());return o}static randInt(r,e,t={}){if(typeof t!="object")throw new TypeError("options must be an object");const{min:s=0,max:o=1e3,random:n=Math.random}=t;if(!Number.isInteger(s))throw new TypeError("min must be an integer");if(!Number.isInteger(o))throw new TypeError("max must be an integer");if(s>=o)throw new RangeError("min must be smaller than max");let l=o-s,h=new v(r,e);for(let u=0;u<r;u++)for(let g=0;g<e;g++){let f=s+Math.round(n()*l);h.set(u,g,f)}return h}static eye(r,e,t){e===void 0&&(e=r),t===void 0&&(t=1);let s=Math.min(r,e),o=this.zeros(r,e);for(let n=0;n<s;n++)o.set(n,n,t);return o}static diag(r,e,t){let s=r.length;e===void 0&&(e=s),t===void 0&&(t=e);let o=Math.min(s,e,t),n=this.zeros(e,t);for(let l=0;l<o;l++)n.set(l,l,r[l]);return n}static min(r,e){r=this.checkMatrix(r),e=this.checkMatrix(e);let t=r.rows,s=r.columns,o=new v(t,s);for(let n=0;n<t;n++)for(let l=0;l<s;l++)o.set(n,l,Math.min(r.get(n,l),e.get(n,l)));return o}static max(r,e){r=this.checkMatrix(r),e=this.checkMatrix(e);let t=r.rows,s=r.columns,o=new this(t,s);for(let n=0;n<t;n++)for(let l=0;l<s;l++)o.set(n,l,Math.max(r.get(n,l),e.get(n,l)));return o}static checkMatrix(r){return z.isMatrix(r)?r:new v(r)}static isMatrix(r){return r!=null&&r.klass==="Matrix"}get size(){return this.rows*this.columns}apply(r){if(typeof r!="function")throw new TypeError("callback must be a function");for(let e=0;e<this.rows;e++)for(let t=0;t<this.columns;t++)r.call(this,e,t);return this}to1DArray(){let r=[];for(let e=0;e<this.rows;e++)for(let t=0;t<this.columns;t++)r.push(this.get(e,t));return r}to2DArray(){let r=[];for(let e=0;e<this.rows;e++){r.push([]);for(let t=0;t<this.columns;t++)r[e].push(this.get(e,t))}return r}toJSON(){return this.to2DArray()}isRowVector(){return this.rows===1}isColumnVector(){return this.columns===1}isVector(){return this.rows===1||this.columns===1}isSquare(){return this.rows===this.columns}isEmpty(){return this.rows===0||this.columns===0}isSymmetric(){if(this.isSquare()){for(let r=0;r<this.rows;r++)for(let e=0;e<=r;e++)if(this.get(r,e)!==this.get(e,r))return!1;return!0}return!1}isDistance(){if(!this.isSymmetric())return!1;for(let r=0;r<this.rows;r++)if(this.get(r,r)!==0)return!1;return!0}isEchelonForm(){let r=0,e=0,t=-1,s=!0,o=!1;for(;r<this.rows&&s;){for(e=0,o=!1;e<this.columns&&o===!1;)this.get(r,e)===0?e++:this.get(r,e)===1&&e>t?(o=!0,t=e):(s=!1,o=!0);r++}return s}isReducedEchelonForm(){let r=0,e=0,t=-1,s=!0,o=!1;for(;r<this.rows&&s;){for(e=0,o=!1;e<this.columns&&o===!1;)this.get(r,e)===0?e++:this.get(r,e)===1&&e>t?(o=!0,t=e):(s=!1,o=!0);for(let n=e+1;n<this.rows;n++)this.get(r,n)!==0&&(s=!1);r++}return s}echelonForm(){let r=this.clone(),e=0,t=0;for(;e<r.rows&&t<r.columns;){let s=e;for(let o=e;o<r.rows;o++)r.get(o,t)>r.get(s,t)&&(s=o);if(r.get(s,t)===0)t++;else{r.swapRows(e,s);let o=r.get(e,t);for(let n=t;n<r.columns;n++)r.set(e,n,r.get(e,n)/o);for(let n=e+1;n<r.rows;n++){let l=r.get(n,t)/r.get(e,t);r.set(n,t,0);for(let h=t+1;h<r.columns;h++)r.set(n,h,r.get(n,h)-r.get(e,h)*l)}e++,t++}}return r}reducedEchelonForm(){let r=this.echelonForm(),e=r.columns,t=r.rows,s=t-1;for(;s>=0;)if(r.maxRow(s)===0)s--;else{let o=0,n=!1;for(;o<t&&n===!1;)r.get(s,o)===1?n=!0:o++;for(let l=0;l<s;l++){let h=r.get(l,o);for(let u=o;u<e;u++){let g=r.get(l,u)-h*r.get(s,u);r.set(l,u,g)}}s--}return r}set(){throw new Error("set method is unimplemented")}get(){throw new Error("get method is unimplemented")}repeat(r={}){if(typeof r!="object")throw new TypeError("options must be an object");const{rows:e=1,columns:t=1}=r;if(!Number.isInteger(e)||e<=0)throw new TypeError("rows must be a positive integer");if(!Number.isInteger(t)||t<=0)throw new TypeError("columns must be a positive integer");let s=new v(this.rows*e,this.columns*t);for(let o=0;o<e;o++)for(let n=0;n<t;n++)s.setSubMatrix(this,this.rows*o,this.columns*n);return s}fill(r){for(let e=0;e<this.rows;e++)for(let t=0;t<this.columns;t++)this.set(e,t,r);return this}neg(){return this.mulS(-1)}getRow(r){G(this,r);let e=[];for(let t=0;t<this.columns;t++)e.push(this.get(r,t));return e}getRowVector(r){return v.rowVector(this.getRow(r))}setRow(r,e){G(this,r),e=et(this,e);for(let t=0;t<this.columns;t++)this.set(r,t,e[t]);return this}swapRows(r,e){G(this,r),G(this,e);for(let t=0;t<this.columns;t++){let s=this.get(r,t);this.set(r,t,this.get(e,t)),this.set(e,t,s)}return this}getColumn(r){Z(this,r);let e=[];for(let t=0;t<this.rows;t++)e.push(this.get(t,r));return e}getColumnVector(r){return v.columnVector(this.getColumn(r))}setColumn(r,e){Z(this,r),e=lt(this,e);for(let t=0;t<this.rows;t++)this.set(t,r,e[t]);return this}swapColumns(r,e){Z(this,r),Z(this,e);for(let t=0;t<this.rows;t++){let s=this.get(t,r);this.set(t,r,this.get(t,e)),this.set(t,e,s)}return this}addRowVector(r){r=et(this,r);for(let e=0;e<this.rows;e++)for(let t=0;t<this.columns;t++)this.set(e,t,this.get(e,t)+r[t]);return this}subRowVector(r){r=et(this,r);for(let e=0;e<this.rows;e++)for(let t=0;t<this.columns;t++)this.set(e,t,this.get(e,t)-r[t]);return this}mulRowVector(r){r=et(this,r);for(let e=0;e<this.rows;e++)for(let t=0;t<this.columns;t++)this.set(e,t,this.get(e,t)*r[t]);return this}divRowVector(r){r=et(this,r);for(let e=0;e<this.rows;e++)for(let t=0;t<this.columns;t++)this.set(e,t,this.get(e,t)/r[t]);return this}addColumnVector(r){r=lt(this,r);for(let e=0;e<this.rows;e++)for(let t=0;t<this.columns;t++)this.set(e,t,this.get(e,t)+r[e]);return this}subColumnVector(r){r=lt(this,r);for(let e=0;e<this.rows;e++)for(let t=0;t<this.columns;t++)this.set(e,t,this.get(e,t)-r[e]);return this}mulColumnVector(r){r=lt(this,r);for(let e=0;e<this.rows;e++)for(let t=0;t<this.columns;t++)this.set(e,t,this.get(e,t)*r[e]);return this}divColumnVector(r){r=lt(this,r);for(let e=0;e<this.rows;e++)for(let t=0;t<this.columns;t++)this.set(e,t,this.get(e,t)/r[e]);return this}mulRow(r,e){G(this,r);for(let t=0;t<this.columns;t++)this.set(r,t,this.get(r,t)*e);return this}mulColumn(r,e){Z(this,r);for(let t=0;t<this.rows;t++)this.set(t,r,this.get(t,r)*e);return this}max(r){if(this.isEmpty())return NaN;switch(r){case"row":{const e=new Array(this.rows).fill(Number.NEGATIVE_INFINITY);for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.get(t,s)>e[t]&&(e[t]=this.get(t,s));return e}case"column":{const e=new Array(this.columns).fill(Number.NEGATIVE_INFINITY);for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.get(t,s)>e[s]&&(e[s]=this.get(t,s));return e}case void 0:{let e=this.get(0,0);for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.get(t,s)>e&&(e=this.get(t,s));return e}default:throw new Error(`invalid option: ${r}`)}}maxIndex(){wt(this);let r=this.get(0,0),e=[0,0];for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.get(t,s)>r&&(r=this.get(t,s),e[0]=t,e[1]=s);return e}min(r){if(this.isEmpty())return NaN;switch(r){case"row":{const e=new Array(this.rows).fill(Number.POSITIVE_INFINITY);for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.get(t,s)<e[t]&&(e[t]=this.get(t,s));return e}case"column":{const e=new Array(this.columns).fill(Number.POSITIVE_INFINITY);for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.get(t,s)<e[s]&&(e[s]=this.get(t,s));return e}case void 0:{let e=this.get(0,0);for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.get(t,s)<e&&(e=this.get(t,s));return e}default:throw new Error(`invalid option: ${r}`)}}minIndex(){wt(this);let r=this.get(0,0),e=[0,0];for(let t=0;t<this.rows;t++)for(let s=0;s<this.columns;s++)this.get(t,s)<r&&(r=this.get(t,s),e[0]=t,e[1]=s);return e}maxRow(r){if(G(this,r),this.isEmpty())return NaN;let e=this.get(r,0);for(let t=1;t<this.columns;t++)this.get(r,t)>e&&(e=this.get(r,t));return e}maxRowIndex(r){G(this,r),wt(this);let e=this.get(r,0),t=[r,0];for(let s=1;s<this.columns;s++)this.get(r,s)>e&&(e=this.get(r,s),t[1]=s);return t}minRow(r){if(G(this,r),this.isEmpty())return NaN;let e=this.get(r,0);for(let t=1;t<this.columns;t++)this.get(r,t)<e&&(e=this.get(r,t));return e}minRowIndex(r){G(this,r),wt(this);let e=this.get(r,0),t=[r,0];for(let s=1;s<this.columns;s++)this.get(r,s)<e&&(e=this.get(r,s),t[1]=s);return t}maxColumn(r){if(Z(this,r),this.isEmpty())return NaN;let e=this.get(0,r);for(let t=1;t<this.rows;t++)this.get(t,r)>e&&(e=this.get(t,r));return e}maxColumnIndex(r){Z(this,r),wt(this);let e=this.get(0,r),t=[0,r];for(let s=1;s<this.rows;s++)this.get(s,r)>e&&(e=this.get(s,r),t[0]=s);return t}minColumn(r){if(Z(this,r),this.isEmpty())return NaN;let e=this.get(0,r);for(let t=1;t<this.rows;t++)this.get(t,r)<e&&(e=this.get(t,r));return e}minColumnIndex(r){Z(this,r),wt(this);let e=this.get(0,r),t=[0,r];for(let s=1;s<this.rows;s++)this.get(s,r)<e&&(e=this.get(s,r),t[0]=s);return t}diag(){let r=Math.min(this.rows,this.columns),e=[];for(let t=0;t<r;t++)e.push(this.get(t,t));return e}norm(r="frobenius"){switch(r){case"max":return this.max();case"frobenius":return Math.sqrt(this.dot(this));default:throw new RangeError(`unknown norm type: ${r}`)}}cumulativeSum(){let r=0;for(let e=0;e<this.rows;e++)for(let t=0;t<this.columns;t++)r+=this.get(e,t),this.set(e,t,r);return this}dot(r){z.isMatrix(r)&&(r=r.to1DArray());let e=this.to1DArray();if(e.length!==r.length)throw new RangeError("vectors do not have the same size");let t=0;for(let s=0;s<e.length;s++)t+=e[s]*r[s];return t}mmul(r){r=v.checkMatrix(r);let e=this.rows,t=this.columns,s=r.columns,o=new v(e,s),n=new Float64Array(t);for(let l=0;l<s;l++){for(let h=0;h<t;h++)n[h]=r.get(h,l);for(let h=0;h<e;h++){let u=0;for(let g=0;g<t;g++)u+=this.get(h,g)*n[g];o.set(h,l,u)}}return o}mpow(r){if(!this.isSquare())throw new RangeError("Matrix must be square");if(!Number.isInteger(r)||r<0)throw new RangeError("Exponent must be a non-negative integer");let e=v.eye(this.rows),t=this;for(let s=r;s>=1;s/=2)(s&1)!==0&&(e=e.mmul(t)),t=t.mmul(t);return e}strassen2x2(r){r=v.checkMatrix(r);let e=new v(2,2);const t=this.get(0,0),s=r.get(0,0),o=this.get(0,1),n=r.get(0,1),l=this.get(1,0),h=r.get(1,0),u=this.get(1,1),g=r.get(1,1),f=(t+u)*(s+g),p=(l+u)*s,k=t*(n-g),w=u*(h-s),y=(t+o)*g,R=(l-t)*(s+n),a=(o-u)*(h+g),j=f+w-y+a,T=k+y,C=p+w,V=f-p+k+R;return e.set(0,0,j),e.set(0,1,T),e.set(1,0,C),e.set(1,1,V),e}strassen3x3(r){r=v.checkMatrix(r);let e=new v(3,3);const t=this.get(0,0),s=this.get(0,1),o=this.get(0,2),n=this.get(1,0),l=this.get(1,1),h=this.get(1,2),u=this.get(2,0),g=this.get(2,1),f=this.get(2,2),p=r.get(0,0),k=r.get(0,1),w=r.get(0,2),y=r.get(1,0),R=r.get(1,1),a=r.get(1,2),j=r.get(2,0),T=r.get(2,1),C=r.get(2,2),V=(t+s+o-n-l-g-f)*R,Q=(t-n)*(-k+R),L=l*(-p+k+y-R-a-j+C),q=(-t+n+l)*(p-k+R),B=(n+l)*(-p+k),c=t*p,S=(-t+u+g)*(p-w+a),I=(-t+u)*(w-a),E=(u+g)*(-p+w),W=(t+s+o-l-h-u-g)*a,Y=g*(-p+w+y-R-a-j+T),J=(-o+g+f)*(R+j-T),X=(o-f)*(R-T),A=o*j,it=(g+f)*(-j+T),_=(-o+l+h)*(a+j-C),ht=(o-h)*(a-C),at=(l+h)*(-j+C),O=s*y,H=h*T,rt=n*w,ot=u*k,x=f*C,Ue=c+A+O,Ye=V+q+B+c+J+A+it,Be=c+S+E+W+A+_+at,Ge=Q+L+q+c+A+_+ht,Je=Q+q+B+c+H,Qe=A+_+ht+at+rt,We=c+S+I+Y+J+X+A,Xe=J+X+A+it+ot,Ke=c+S+I+E+x;return e.set(0,0,Ue),e.set(0,1,Ye),e.set(0,2,Be),e.set(1,0,Ge),e.set(1,1,Je),e.set(1,2,Qe),e.set(2,0,We),e.set(2,1,Xe),e.set(2,2,Ke),e}mmulStrassen(r){r=v.checkMatrix(r);let e=this.clone(),t=e.rows,s=e.columns,o=r.rows,n=r.columns;s!==o&&console.warn(`Multiplying ${t} x ${s} and ${o} x ${n} matrix: dimensions do not match.`);function l(f,p,k){let w=f.rows,y=f.columns;if(w===p&&y===k)return f;{let R=z.zeros(p,k);return R=R.setSubMatrix(f,0,0),R}}let h=Math.max(t,o),u=Math.max(s,n);e=l(e,h,u),r=l(r,h,u);function g(f,p,k,w){if(k<=512||w<=512)return f.mmul(p);k%2===1&&w%2===1?(f=l(f,k+1,w+1),p=l(p,k+1,w+1)):k%2===1?(f=l(f,k+1,w),p=l(p,k+1,w)):w%2===1&&(f=l(f,k,w+1),p=l(p,k,w+1));let y=parseInt(f.rows/2,10),R=parseInt(f.columns/2,10),a=f.subMatrix(0,y-1,0,R-1),j=p.subMatrix(0,y-1,0,R-1),T=f.subMatrix(0,y-1,R,f.columns-1),C=p.subMatrix(0,y-1,R,p.columns-1),V=f.subMatrix(y,f.rows-1,0,R-1),Q=p.subMatrix(y,p.rows-1,0,R-1),L=f.subMatrix(y,f.rows-1,R,f.columns-1),q=p.subMatrix(y,p.rows-1,R,p.columns-1),B=g(z.add(a,L),z.add(j,q),y,R),c=g(z.add(V,L),j,y,R),S=g(a,z.sub(C,q),y,R),I=g(L,z.sub(Q,j),y,R),E=g(z.add(a,T),q,y,R),W=g(z.sub(V,a),z.add(j,C),y,R),Y=g(z.sub(T,L),z.add(Q,q),y,R),J=z.add(B,I);J.sub(E),J.add(Y);let X=z.add(S,E),A=z.add(c,I),it=z.sub(B,c);it.add(S),it.add(W);let _=z.zeros(2*J.rows,2*J.columns);return _=_.setSubMatrix(J,0,0),_=_.setSubMatrix(X,J.rows,0),_=_.setSubMatrix(A,0,J.columns),_=_.setSubMatrix(it,J.rows,J.columns),_.subMatrix(0,k-1,0,w-1)}return g(e,r,h,u)}scaleRows(r={}){if(typeof r!="object")throw new TypeError("options must be an object");const{min:e=0,max:t=1}=r;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(t))throw new TypeError("max must be a number");if(e>=t)throw new RangeError("min must be smaller than max");let s=new v(this.rows,this.columns);for(let o=0;o<this.rows;o++){const n=this.getRow(o);n.length>0&&m(n,{min:e,max:t,output:n}),s.setRow(o,n)}return s}scaleColumns(r={}){if(typeof r!="object")throw new TypeError("options must be an object");const{min:e=0,max:t=1}=r;if(!Number.isFinite(e))throw new TypeError("min must be a number");if(!Number.isFinite(t))throw new TypeError("max must be a number");if(e>=t)throw new RangeError("min must be smaller than max");let s=new v(this.rows,this.columns);for(let o=0;o<this.columns;o++){const n=this.getColumn(o);n.length&&m(n,{min:e,max:t,output:n}),s.setColumn(o,n)}return s}flipRows(){const r=Math.ceil(this.columns/2);for(let e=0;e<this.rows;e++)for(let t=0;t<r;t++){let s=this.get(e,t),o=this.get(e,this.columns-1-t);this.set(e,t,o),this.set(e,this.columns-1-t,s)}return this}flipColumns(){const r=Math.ceil(this.rows/2);for(let e=0;e<this.columns;e++)for(let t=0;t<r;t++){let s=this.get(t,e),o=this.get(this.rows-1-t,e);this.set(t,e,o),this.set(this.rows-1-t,e,s)}return this}kroneckerProduct(r){r=v.checkMatrix(r);let e=this.rows,t=this.columns,s=r.rows,o=r.columns,n=new v(e*s,t*o);for(let l=0;l<e;l++)for(let h=0;h<t;h++)for(let u=0;u<s;u++)for(let g=0;g<o;g++)n.set(s*l+u,o*h+g,this.get(l,h)*r.get(u,g));return n}kroneckerSum(r){if(r=v.checkMatrix(r),!this.isSquare()||!r.isSquare())throw new Error("Kronecker Sum needs two Square Matrices");let e=this.rows,t=r.rows,s=this.kroneckerProduct(v.eye(t,t)),o=v.eye(e,e).kroneckerProduct(r);return s.add(o)}transpose(){let r=new v(this.columns,this.rows);for(let e=0;e<this.rows;e++)for(let t=0;t<this.columns;t++)r.set(t,e,this.get(e,t));return r}sortRows(r=Yt){for(let e=0;e<this.rows;e++)this.setRow(e,this.getRow(e).sort(r));return this}sortColumns(r=Yt){for(let e=0;e<this.columns;e++)this.setColumn(e,this.getColumn(e).sort(r));return this}subMatrix(r,e,t,s){$t(this,r,e,t,s);let o=new v(e-r+1,s-t+1);for(let n=r;n<=e;n++)for(let l=t;l<=s;l++)o.set(n-r,l-t,this.get(n,l));return o}subMatrixRow(r,e,t){if(e===void 0&&(e=0),t===void 0&&(t=this.columns-1),e>t||e<0||e>=this.columns||t<0||t>=this.columns)throw new RangeError("Argument out of range");let s=new v(r.length,t-e+1);for(let o=0;o<r.length;o++)for(let n=e;n<=t;n++){if(r[o]<0||r[o]>=this.rows)throw new RangeError(`Row index out of range: ${r[o]}`);s.set(o,n-e,this.get(r[o],n))}return s}subMatrixColumn(r,e,t){if(e===void 0&&(e=0),t===void 0&&(t=this.rows-1),e>t||e<0||e>=this.rows||t<0||t>=this.rows)throw new RangeError("Argument out of range");let s=new v(t-e+1,r.length);for(let o=0;o<r.length;o++)for(let n=e;n<=t;n++){if(r[o]<0||r[o]>=this.columns)throw new RangeError(`Column index out of range: ${r[o]}`);s.set(n-e,o,this.get(n,r[o]))}return s}setSubMatrix(r,e,t){if(r=v.checkMatrix(r),r.isEmpty())return this;let s=e+r.rows-1,o=t+r.columns-1;$t(this,e,s,t,o);for(let n=0;n<r.rows;n++)for(let l=0;l<r.columns;l++)this.set(e+n,t+l,r.get(n,l));return this}selection(r,e){ct(this,r),Ft(this,e);let t=new v(r.length,e.length);for(let s=0;s<r.length;s++){let o=r[s];for(let n=0;n<e.length;n++){let l=e[n];t.set(s,n,this.get(o,l))}}return t}trace(){let r=Math.min(this.rows,this.columns),e=0;for(let t=0;t<r;t++)e+=this.get(t,t);return e}clone(){return this.constructor.copy(this,new v(this.rows,this.columns))}static copy(r,e){for(const[t,s,o]of r.entries())e.set(t,s,o);return e}sum(r){switch(r){case"row":return ee(this);case"column":return se(this);case void 0:return re(this);default:throw new Error(`invalid option: ${r}`)}}product(r){switch(r){case"row":return oe(this);case"column":return ie(this);case void 0:return ne(this);default:throw new Error(`invalid option: ${r}`)}}mean(r){const e=this.sum(r);switch(r){case"row":{for(let t=0;t<this.rows;t++)e[t]/=this.columns;return e}case"column":{for(let t=0;t<this.columns;t++)e[t]/=this.rows;return e}case void 0:return e/this.size;default:throw new Error(`invalid option: ${r}`)}}variance(r,e={}){if(typeof r=="object"&&(e=r,r=void 0),typeof e!="object")throw new TypeError("options must be an object");const{unbiased:t=!0,mean:s=this.mean(r)}=e;if(typeof t!="boolean")throw new TypeError("unbiased must be a boolean");switch(r){case"row":{if(!M.isAnyArray(s))throw new TypeError("mean must be an array");return le(this,t,s)}case"column":{if(!M.isAnyArray(s))throw new TypeError("mean must be an array");return he(this,t,s)}case void 0:{if(typeof s!="number")throw new TypeError("mean must be a number");return ue(this,t,s)}default:throw new Error(`invalid option: ${r}`)}}standardDeviation(r,e){typeof r=="object"&&(e=r,r=void 0);const t=this.variance(r,e);if(r===void 0)return Math.sqrt(t);for(let s=0;s<t.length;s++)t[s]=Math.sqrt(t[s]);return t}center(r,e={}){if(typeof r=="object"&&(e=r,r=void 0),typeof e!="object")throw new TypeError("options must be an object");const{center:t=this.mean(r)}=e;switch(r){case"row":{if(!M.isAnyArray(t))throw new TypeError("center must be an array");return fe(this,t),this}case"column":{if(!M.isAnyArray(t))throw new TypeError("center must be an array");return ae(this,t),this}case void 0:{if(typeof t!="number")throw new TypeError("center must be a number");return ce(this,t),this}default:throw new Error(`invalid option: ${r}`)}}scale(r,e={}){if(typeof r=="object"&&(e=r,r=void 0),typeof e!="object")throw new TypeError("options must be an object");let t=e.scale;switch(r){case"row":{if(t===void 0)t=ge(this);else if(!M.isAnyArray(t))throw new TypeError("scale must be an array");return me(this,t),this}case"column":{if(t===void 0)t=we(this);else if(!M.isAnyArray(t))throw new TypeError("scale must be an array");return pe(this,t),this}case void 0:{if(t===void 0)t=de(this);else if(typeof t!="number")throw new TypeError("scale must be a number");return ye(this,t),this}default:throw new Error(`invalid option: ${r}`)}}toString(r){return N(this,r)}[Symbol.iterator](){return this.entries()}*entries(){for(let r=0;r<this.rows;r++)for(let e=0;e<this.columns;e++)yield[r,e,this.get(r,e)]}*values(){for(let r=0;r<this.rows;r++)for(let e=0;e<this.columns;e++)yield this.get(r,e)}}z.prototype.klass="Matrix",typeof Symbol<"u"&&(z.prototype[Symbol.for("nodejs.util.inspect.custom")]=D);function Yt(i,r){return i-r}function Me(i){return i.every(r=>typeof r=="number")}z.random=z.rand,z.randomInt=z.randInt,z.diagonal=z.diag,z.prototype.diagonal=z.prototype.diag,z.identity=z.eye,z.prototype.negate=z.prototype.neg,z.prototype.tensorProduct=z.prototype.kroneckerProduct;const Tt=class Tt extends z{constructor(e,t){super();zt(this,St);dt(this,"data");if(Tt.isMatrix(e))Pt(this,St,Ot).call(this,e.rows,e.columns),Tt.copy(e,this);else if(Number.isInteger(e)&&e>=0)Pt(this,St,Ot).call(this,e,t);else if(M.isAnyArray(e)){const s=e;if(e=s.length,t=e?s[0].length:0,typeof t!="number")throw new TypeError("Data must be a 2D array with at least one element");this.data=[];for(let o=0;o<e;o++){if(s[o].length!==t)throw new RangeError("Inconsistent array dimensions");if(!Me(s[o]))throw new TypeError("Input data contains non-numeric values");this.data.push(Float64Array.from(s[o]))}this.rows=e,this.columns=t}else throw new TypeError("First argument must be a positive number or an array")}set(e,t,s){return this.data[e][t]=s,this}get(e,t){return this.data[e][t]}removeRow(e){return G(this,e),this.data.splice(e,1),this.rows-=1,this}addRow(e,t){return t===void 0&&(t=e,e=this.rows),G(this,e,!0),t=Float64Array.from(et(this,t)),this.data.splice(e,0,t),this.rows+=1,this}removeColumn(e){Z(this,e);for(let t=0;t<this.rows;t++){const s=new Float64Array(this.columns-1);for(let o=0;o<e;o++)s[o]=this.data[t][o];for(let o=e+1;o<this.columns;o++)s[o-1]=this.data[t][o];this.data[t]=s}return this.columns-=1,this}addColumn(e,t){typeof t>"u"&&(t=e,e=this.columns),Z(this,e,!0),t=lt(this,t);for(let s=0;s<this.rows;s++){const o=new Float64Array(this.columns+1);let n=0;for(;n<e;n++)o[n]=this.data[s][n];for(o[n++]=t[s];n<this.columns+1;n++)o[n]=this.data[s][n-1];this.data[s]=o}return this.columns+=1,this}};St=new WeakSet,Ot=function(e,t){if(this.data=[],Number.isInteger(t)&&t>=0)for(let s=0;s<e;s++)this.data.push(new Float64Array(t));else throw new TypeError("nColumns must be a positive integer");this.rows=e,this.columns=t};let v=Tt;K(z,v);const Nt=class Nt extends z{constructor(e){super();zt(this,tt);if(v.isMatrix(e)){if(!e.isSymmetric())throw new TypeError("not symmetric data");Dt(this,tt,v.copy(e,new v(e.rows,e.rows)))}else if(Number.isInteger(e)&&e>=0)Dt(this,tt,new v(e,e));else if(Dt(this,tt,new v(e)),!this.isSymmetric())throw new TypeError("not symmetric data")}get size(){return nt(this,tt).size}get rows(){return nt(this,tt).rows}get columns(){return nt(this,tt).columns}get diagonalSize(){return this.rows}static isSymmetricMatrix(e){return v.isMatrix(e)&&e.klassType==="SymmetricMatrix"}static zeros(e){return new this(e)}static ones(e){return new this(e).fill(1)}clone(){const e=new Nt(this.diagonalSize);for(const[t,s,o]of this.upperRightEntries())e.set(t,s,o);return e}toMatrix(){return new v(this)}get(e,t){return nt(this,tt).get(e,t)}set(e,t,s){return nt(this,tt).set(e,t,s),nt(this,tt).set(t,e,s),this}removeCross(e){return nt(this,tt).removeRow(e),nt(this,tt).removeColumn(e),this}addCross(e,t){t===void 0&&(t=e,e=this.diagonalSize);const s=t.slice();return s.splice(e,1),nt(this,tt).addRow(e,s),nt(this,tt).addColumn(e,t),this}applyMask(e){if(e.length!==this.diagonalSize)throw new RangeError("Mask size do not match with matrix size");const t=[];for(const[s,o]of e.entries())o||t.push(s);t.reverse();for(const s of t)this.removeCross(s);return this}toCompact(){const{diagonalSize:e}=this,t=new Array(e*(e+1)/2);for(let s=0,o=0,n=0;n<t.length;n++)t[n]=this.get(o,s),++s>=e&&(s=++o);return t}static fromCompact(e){const t=e.length,s=(Math.sqrt(8*t+1)-1)/2;if(!Number.isInteger(s))throw new TypeError(`This array is not a compact representation of a Symmetric Matrix, ${JSON.stringify(e)}`);const o=new Nt(s);for(let n=0,l=0,h=0;h<t;h++)o.set(n,l,e[h]),++n>=s&&(n=++l);return o}*upperRightEntries(){for(let e=0,t=0;e<this.diagonalSize;void 0){const s=this.get(e,t);yield[e,t,s],++t>=this.diagonalSize&&(t=++e)}}*upperRightValues(){for(let e=0,t=0;e<this.diagonalSize;void 0)yield this.get(e,t),++t>=this.diagonalSize&&(t=++e)}};tt=new WeakMap;let gt=Nt;gt.prototype.klassType="SymmetricMatrix";class jt extends gt{static isDistanceMatrix(r){return gt.isSymmetricMatrix(r)&&r.klassSubType==="DistanceMatrix"}constructor(r){if(super(r),!this.isDistance())throw new TypeError("Provided arguments do no produce a distance matrix")}set(r,e,t){return r===e&&(t=0),super.set(r,e,t)}addCross(r,e){return e===void 0&&(e=r,r=this.diagonalSize),e=e.slice(),e[r]=0,super.addCross(r,e)}toSymmetricMatrix(){return new gt(this)}clone(){const r=new jt(this.diagonalSize);for(const[e,t,s]of this.upperRightEntries())e!==t&&r.set(e,t,s);return r}toCompact(){const{diagonalSize:r}=this,e=(r-1)*r/2,t=new Array(e);for(let s=1,o=0,n=0;n<t.length;n++)t[n]=this.get(o,s),++s>=r&&(s=++o+1);return t}static fromCompact(r){const e=r.length;if(e===0)return new this(0);const t=(Math.sqrt(8*e+1)+1)/2;if(!Number.isInteger(t))throw new TypeError(`This array is not a compact representation of a DistanceMatrix, ${JSON.stringify(r)}`);const s=new this(t);for(let o=1,n=0,l=0;l<e;l++)s.set(o,n,r[l]),++o>=t&&(o=++n+1);return s}}jt.prototype.klassSubType="DistanceMatrix";class ut extends z{constructor(r,e,t){super(),this.matrix=r,this.rows=e,this.columns=t}}class Se extends ut{constructor(r,e){Z(r,e),super(r,r.rows,1),this.column=e}set(r,e,t){return this.matrix.set(r,this.column,t),this}get(r){return this.matrix.get(r,this.column)}}class be extends ut{constructor(r,e){Ft(r,e),super(r,r.rows,e.length),this.columnIndices=e}set(r,e,t){return this.matrix.set(r,this.columnIndices[e],t),this}get(r,e){return this.matrix.get(r,this.columnIndices[e])}}class Ee extends ut{constructor(r){super(r,r.rows,r.columns)}set(r,e,t){return this.matrix.set(r,this.columns-e-1,t),this}get(r,e){return this.matrix.get(r,this.columns-e-1)}}class je extends ut{constructor(r){super(r,r.rows,r.columns)}set(r,e,t){return this.matrix.set(this.rows-r-1,e,t),this}get(r,e){return this.matrix.get(this.rows-r-1,e)}}class ke extends ut{constructor(r,e){G(r,e),super(r,1,r.columns),this.row=e}set(r,e,t){return this.matrix.set(this.row,e,t),this}get(r,e){return this.matrix.get(this.row,e)}}class ve extends ut{constructor(r,e){ct(r,e),super(r,e.length,r.columns),this.rowIndices=e}set(r,e,t){return this.matrix.set(this.rowIndices[r],e,t),this}get(r,e){return this.matrix.get(this.rowIndices[r],e)}}class kt extends ut{constructor(r,e,t){ct(r,e),Ft(r,t),super(r,e.length,t.length),this.rowIndices=e,this.columnIndices=t}set(r,e,t){return this.matrix.set(this.rowIndices[r],this.columnIndices[e],t),this}get(r,e){return this.matrix.get(this.rowIndices[r],this.columnIndices[e])}}class Re extends ut{constructor(r,e,t,s,o){$t(r,e,t,s,o),super(r,t-e+1,o-s+1),this.startRow=e,this.startColumn=s}set(r,e,t){return this.matrix.set(this.startRow+r,this.startColumn+e,t),this}get(r,e){return this.matrix.get(this.startRow+r,this.startColumn+e)}}class Ie extends ut{constructor(r){super(r,r.columns,r.rows)}set(r,e,t){return this.matrix.set(e,r,t),this}get(r,e){return this.matrix.get(e,r)}}class Bt extends z{constructor(r,e={}){const{rows:t=1}=e;if(r.length%t!==0)throw new Error("the data length is not divisible by the number of rows");super(),this.rows=t,this.columns=r.length/t,this.data=r}set(r,e,t){let s=this._calculateIndex(r,e);return this.data[s]=t,this}get(r,e){let t=this._calculateIndex(r,e);return this.data[t]}_calculateIndex(r,e){return r*this.columns+e}}class st extends z{constructor(r){super(),this.data=r,this.rows=r.length,this.columns=r[0].length}set(r,e,t){return this.data[r][e]=t,this}get(r,e){return this.data[r][e]}}function Te(i,r){if(M.isAnyArray(i))return i[0]&&M.isAnyArray(i[0])?new st(i):new Bt(i,r);throw new Error("the argument is not an array")}class vt{constructor(r){r=st.checkMatrix(r);let e=r.clone(),t=e.rows,s=e.columns,o=new Float64Array(t),n=1,l,h,u,g,f,p,k,w,y;for(l=0;l<t;l++)o[l]=l;for(w=new Float64Array(t),h=0;h<s;h++){for(l=0;l<t;l++)w[l]=e.get(l,h);for(l=0;l<t;l++){for(y=Math.min(l,h),f=0,u=0;u<y;u++)f+=e.get(l,u)*w[u];w[l]-=f,e.set(l,h,w[l])}for(g=h,l=h+1;l<t;l++)Math.abs(w[l])>Math.abs(w[g])&&(g=l);if(g!==h){for(u=0;u<s;u++)p=e.get(g,u),e.set(g,u,e.get(h,u)),e.set(h,u,p);k=o[g],o[g]=o[h],o[h]=k,n=-n}if(h<t&&e.get(h,h)!==0)for(l=h+1;l<t;l++)e.set(l,h,e.get(l,h)/e.get(h,h))}this.LU=e,this.pivotVector=o,this.pivotSign=n}isSingular(){let r=this.LU,e=r.columns;for(let t=0;t<e;t++)if(r.get(t,t)===0)return!0;return!1}solve(r){r=v.checkMatrix(r);let e=this.LU;if(e.rows!==r.rows)throw new Error("Invalid matrix dimensions");if(this.isSingular())throw new Error("LU matrix is singular");let s=r.columns,o=r.subMatrixRow(this.pivotVector,0,s-1),n=e.columns,l,h,u;for(u=0;u<n;u++)for(l=u+1;l<n;l++)for(h=0;h<s;h++)o.set(l,h,o.get(l,h)-o.get(u,h)*e.get(l,u));for(u=n-1;u>=0;u--){for(h=0;h<s;h++)o.set(u,h,o.get(u,h)/e.get(u,u));for(l=0;l<u;l++)for(h=0;h<s;h++)o.set(l,h,o.get(l,h)-o.get(u,h)*e.get(l,u))}return o}get determinant(){let r=this.LU;if(!r.isSquare())throw new Error("Matrix must be square");let e=this.pivotSign,t=r.columns;for(let s=0;s<t;s++)e*=r.get(s,s);return e}get lowerTriangularMatrix(){let r=this.LU,e=r.rows,t=r.columns,s=new v(e,t);for(let o=0;o<e;o++)for(let n=0;n<t;n++)o>n?s.set(o,n,r.get(o,n)):o===n?s.set(o,n,1):s.set(o,n,0);return s}get upperTriangularMatrix(){let r=this.LU,e=r.rows,t=r.columns,s=new v(e,t);for(let o=0;o<e;o++)for(let n=0;n<t;n++)o<=n?s.set(o,n,r.get(o,n)):s.set(o,n,0);return s}get pivotPermutationVector(){return Array.from(this.pivotVector)}}function ft(i,r){let e=0;return Math.abs(i)>Math.abs(r)?(e=r/i,Math.abs(i)*Math.sqrt(1+e*e)):r!==0?(e=i/r,Math.abs(r)*Math.sqrt(1+e*e)):0}class Ct{constructor(r){r=st.checkMatrix(r);let e=r.clone(),t=r.rows,s=r.columns,o=new Float64Array(s),n,l,h,u;for(h=0;h<s;h++){let g=0;for(n=h;n<t;n++)g=ft(g,e.get(n,h));if(g!==0){for(e.get(h,h)<0&&(g=-g),n=h;n<t;n++)e.set(n,h,e.get(n,h)/g);for(e.set(h,h,e.get(h,h)+1),l=h+1;l<s;l++){for(u=0,n=h;n<t;n++)u+=e.get(n,h)*e.get(n,l);for(u=-u/e.get(h,h),n=h;n<t;n++)e.set(n,l,e.get(n,l)+u*e.get(n,h))}}o[h]=-g}this.QR=e,this.Rdiag=o}solve(r){r=v.checkMatrix(r);let e=this.QR,t=e.rows;if(r.rows!==t)throw new Error("Matrix row dimensions must agree");if(!this.isFullRank())throw new Error("Matrix is rank deficient");let s=r.columns,o=r.clone(),n=e.columns,l,h,u,g;for(u=0;u<n;u++)for(h=0;h<s;h++){for(g=0,l=u;l<t;l++)g+=e.get(l,u)*o.get(l,h);for(g=-g/e.get(u,u),l=u;l<t;l++)o.set(l,h,o.get(l,h)+g*e.get(l,u))}for(u=n-1;u>=0;u--){for(h=0;h<s;h++)o.set(u,h,o.get(u,h)/this.Rdiag[u]);for(l=0;l<u;l++)for(h=0;h<s;h++)o.set(l,h,o.get(l,h)-o.get(u,h)*e.get(l,u))}return o.subMatrix(0,n-1,0,s-1)}isFullRank(){let r=this.QR.columns;for(let e=0;e<r;e++)if(this.Rdiag[e]===0)return!1;return!0}get upperTriangularMatrix(){let r=this.QR,e=r.columns,t=new v(e,e),s,o;for(s=0;s<e;s++)for(o=0;o<e;o++)s<o?t.set(s,o,r.get(s,o)):s===o?t.set(s,o,this.Rdiag[s]):t.set(s,o,0);return t}get orthogonalMatrix(){let r=this.QR,e=r.rows,t=r.columns,s=new v(e,t),o,n,l,h;for(l=t-1;l>=0;l--){for(o=0;o<e;o++)s.set(o,l,0);for(s.set(l,l,1),n=l;n<t;n++)if(r.get(l,l)!==0){for(h=0,o=l;o<e;o++)h+=r.get(o,l)*s.get(o,n);for(h=-h/r.get(l,l),o=l;o<e;o++)s.set(o,n,s.get(o,n)+h*r.get(o,l))}}return s}}class pt{constructor(r,e={}){if(r=st.checkMatrix(r),r.isEmpty())throw new Error("Matrix must be non-empty");let t=r.rows,s=r.columns;const{computeLeftSingularVectors:o=!0,computeRightSingularVectors:n=!0,autoTranspose:l=!1}=e;let h=!!o,u=!!n,g=!1,f;if(t<s)if(!l)f=r.clone(),console.warn("Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose");else{f=r.transpose(),t=f.rows,s=f.columns,g=!0;let c=h;h=u,u=c}else f=r.clone();let p=Math.min(t,s),k=Math.min(t+1,s),w=new Float64Array(k),y=new v(t,p),R=new v(s,s),a=new Float64Array(s),j=new Float64Array(t),T=new Float64Array(k);for(let c=0;c<k;c++)T[c]=c;let C=Math.min(t-1,s),V=Math.max(0,Math.min(s-2,t)),Q=Math.max(C,V);for(let c=0;c<Q;c++){if(c<C){w[c]=0;for(let S=c;S<t;S++)w[c]=ft(w[c],f.get(S,c));if(w[c]!==0){f.get(c,c)<0&&(w[c]=-w[c]);for(let S=c;S<t;S++)f.set(S,c,f.get(S,c)/w[c]);f.set(c,c,f.get(c,c)+1)}w[c]=-w[c]}for(let S=c+1;S<s;S++){if(c<C&&w[c]!==0){let I=0;for(let E=c;E<t;E++)I+=f.get(E,c)*f.get(E,S);I=-I/f.get(c,c);for(let E=c;E<t;E++)f.set(E,S,f.get(E,S)+I*f.get(E,c))}a[S]=f.get(c,S)}if(h&&c<C)for(let S=c;S<t;S++)y.set(S,c,f.get(S,c));if(c<V){a[c]=0;for(let S=c+1;S<s;S++)a[c]=ft(a[c],a[S]);if(a[c]!==0){a[c+1]<0&&(a[c]=0-a[c]);for(let S=c+1;S<s;S++)a[S]/=a[c];a[c+1]+=1}if(a[c]=-a[c],c+1<t&&a[c]!==0){for(let S=c+1;S<t;S++)j[S]=0;for(let S=c+1;S<t;S++)for(let I=c+1;I<s;I++)j[S]+=a[I]*f.get(S,I);for(let S=c+1;S<s;S++){let I=-a[S]/a[c+1];for(let E=c+1;E<t;E++)f.set(E,S,f.get(E,S)+I*j[E])}}if(u)for(let S=c+1;S<s;S++)R.set(S,c,a[S])}}let L=Math.min(s,t+1);if(C<s&&(w[C]=f.get(C,C)),t<L&&(w[L-1]=0),V+1<L&&(a[V]=f.get(V,L-1)),a[L-1]=0,h){for(let c=C;c<p;c++){for(let S=0;S<t;S++)y.set(S,c,0);y.set(c,c,1)}for(let c=C-1;c>=0;c--)if(w[c]!==0){for(let S=c+1;S<p;S++){let I=0;for(let E=c;E<t;E++)I+=y.get(E,c)*y.get(E,S);I=-I/y.get(c,c);for(let E=c;E<t;E++)y.set(E,S,y.get(E,S)+I*y.get(E,c))}for(let S=c;S<t;S++)y.set(S,c,-y.get(S,c));y.set(c,c,1+y.get(c,c));for(let S=0;S<c-1;S++)y.set(S,c,0)}else{for(let S=0;S<t;S++)y.set(S,c,0);y.set(c,c,1)}}if(u)for(let c=s-1;c>=0;c--){if(c<V&&a[c]!==0)for(let S=c+1;S<s;S++){let I=0;for(let E=c+1;E<s;E++)I+=R.get(E,c)*R.get(E,S);I=-I/R.get(c+1,c);for(let E=c+1;E<s;E++)R.set(E,S,R.get(E,S)+I*R.get(E,c))}for(let S=0;S<s;S++)R.set(S,c,0);R.set(c,c,1)}let q=L-1,B=Number.EPSILON;for(;L>0;){let c,S;for(c=L-2;c>=-1&&c!==-1;c--){const I=Number.MIN_VALUE+B*Math.abs(w[c]+Math.abs(w[c+1]));if(Math.abs(a[c])<=I||Number.isNaN(a[c])){a[c]=0;break}}if(c===L-2)S=4;else{let I;for(I=L-1;I>=c&&I!==c;I--){let E=(I!==L?Math.abs(a[I]):0)+(I!==c+1?Math.abs(a[I-1]):0);if(Math.abs(w[I])<=B*E){w[I]=0;break}}I===c?S=3:I===L-1?S=1:(S=2,c=I)}switch(c++,S){case 1:{let I=a[L-2];a[L-2]=0;for(let E=L-2;E>=c;E--){let W=ft(w[E],I),Y=w[E]/W,J=I/W;if(w[E]=W,E!==c&&(I=-J*a[E-1],a[E-1]=Y*a[E-1]),u)for(let X=0;X<s;X++)W=Y*R.get(X,E)+J*R.get(X,L-1),R.set(X,L-1,-J*R.get(X,E)+Y*R.get(X,L-1)),R.set(X,E,W)}break}case 2:{let I=a[c-1];a[c-1]=0;for(let E=c;E<L;E++){let W=ft(w[E],I),Y=w[E]/W,J=I/W;if(w[E]=W,I=-J*a[E],a[E]=Y*a[E],h)for(let X=0;X<t;X++)W=Y*y.get(X,E)+J*y.get(X,c-1),y.set(X,c-1,-J*y.get(X,E)+Y*y.get(X,c-1)),y.set(X,E,W)}break}case 3:{const I=Math.max(Math.abs(w[L-1]),Math.abs(w[L-2]),Math.abs(a[L-2]),Math.abs(w[c]),Math.abs(a[c])),E=w[L-1]/I,W=w[L-2]/I,Y=a[L-2]/I,J=w[c]/I,X=a[c]/I,A=((W+E)*(W-E)+Y*Y)/2,it=E*Y*(E*Y);let _=0;(A!==0||it!==0)&&(A<0?_=0-Math.sqrt(A*A+it):_=Math.sqrt(A*A+it),_=it/(A+_));let ht=(J+E)*(J-E)+_,at=J*X;for(let O=c;O<L-1;O++){let H=ft(ht,at);H===0&&(H=Number.MIN_VALUE);let rt=ht/H,ot=at/H;if(O!==c&&(a[O-1]=H),ht=rt*w[O]+ot*a[O],a[O]=rt*a[O]-ot*w[O],at=ot*w[O+1],w[O+1]=rt*w[O+1],u)for(let x=0;x<s;x++)H=rt*R.get(x,O)+ot*R.get(x,O+1),R.set(x,O+1,-ot*R.get(x,O)+rt*R.get(x,O+1)),R.set(x,O,H);if(H=ft(ht,at),H===0&&(H=Number.MIN_VALUE),rt=ht/H,ot=at/H,w[O]=H,ht=rt*a[O]+ot*w[O+1],w[O+1]=-ot*a[O]+rt*w[O+1],at=ot*a[O+1],a[O+1]=rt*a[O+1],h&&O<t-1)for(let x=0;x<t;x++)H=rt*y.get(x,O)+ot*y.get(x,O+1),y.set(x,O+1,-ot*y.get(x,O)+rt*y.get(x,O+1)),y.set(x,O,H)}a[L-2]=ht;break}case 4:{if(w[c]<=0&&(w[c]=w[c]<0?-w[c]:0,u))for(let I=0;I<=q;I++)R.set(I,c,-R.get(I,c));for(;c<q&&!(w[c]>=w[c+1]);){let I=w[c];if(w[c]=w[c+1],w[c+1]=I,u&&c<s-1)for(let E=0;E<s;E++)I=R.get(E,c+1),R.set(E,c+1,R.get(E,c)),R.set(E,c,I);if(h&&c<t-1)for(let E=0;E<t;E++)I=y.get(E,c+1),y.set(E,c+1,y.get(E,c)),y.set(E,c,I);c++}L--;break}}}if(g){let c=R;R=y,y=c}this.m=t,this.n=s,this.s=w,this.U=y,this.V=R}solve(r){let e=r,t=this.threshold,s=this.s.length,o=v.zeros(s,s);for(let p=0;p<s;p++)Math.abs(this.s[p])<=t?o.set(p,p,0):o.set(p,p,1/this.s[p]);let n=this.U,l=this.rightSingularVectors,h=l.mmul(o),u=l.rows,g=n.rows,f=v.zeros(u,g);for(let p=0;p<u;p++)for(let k=0;k<g;k++){let w=0;for(let y=0;y<s;y++)w+=h.get(p,y)*n.get(k,y);f.set(p,k,w)}return f.mmul(e)}solveForDiagonal(r){return this.solve(v.diag(r))}inverse(){let r=this.V,e=this.threshold,t=r.rows,s=r.columns,o=new v(t,this.s.length);for(let g=0;g<t;g++)for(let f=0;f<s;f++)Math.abs(this.s[f])>e&&o.set(g,f,r.get(g,f)/this.s[f]);let n=this.U,l=n.rows,h=n.columns,u=new v(t,l);for(let g=0;g<t;g++)for(let f=0;f<l;f++){let p=0;for(let k=0;k<h;k++)p+=o.get(g,k)*n.get(f,k);u.set(g,f,p)}return u}get condition(){return this.s[0]/this.s[Math.min(this.m,this.n)-1]}get norm2(){return this.s[0]}get rank(){let r=Math.max(this.m,this.n)*this.s[0]*Number.EPSILON,e=0,t=this.s;for(let s=0,o=t.length;s<o;s++)t[s]>r&&e++;return e}get diagonal(){return Array.from(this.s)}get threshold(){return Number.EPSILON/2*Math.max(this.m,this.n)*this.s[0]}get leftSingularVectors(){return this.U}get rightSingularVectors(){return this.V}get diagonalMatrix(){return v.diag(this.s)}}function Ne(i,r=!1){return i=st.checkMatrix(i),r?new pt(i).inverse():Gt(i,v.eye(i.rows))}function Gt(i,r,e=!1){return i=st.checkMatrix(i),r=st.checkMatrix(r),e?new pt(i).solve(r):i.isSquare()?new vt(i).solve(r):new Ct(i).solve(r)}function Rt(i){if(i=v.checkMatrix(i),i.isSquare()){if(i.columns===0)return 1;let r,e,t,s;if(i.columns===2)return r=i.get(0,0),e=i.get(0,1),t=i.get(1,0),s=i.get(1,1),r*s-e*t;if(i.columns===3){let o,n,l;return o=new kt(i,[1,2],[1,2]),n=new kt(i,[1,2],[0,2]),l=new kt(i,[1,2],[0,1]),r=i.get(0,0),e=i.get(0,1),t=i.get(0,2),r*Rt(o)-e*Rt(n)+t*Rt(l)}else return new vt(i).determinant}else throw Error("determinant can only be calculated for a square matrix")}function De(i,r){let e=[];for(let t=0;t<i;t++)t!==r&&e.push(t);return e}function Le(i,r,e,t=1e-9,s=1e-9){if(i>s)return new Array(r.rows+1).fill(0);{let o=r.addRow(e,[0]);for(let n=0;n<o.rows;n++)Math.abs(o.get(n,0))<t&&o.set(n,0,0);return o.to1DArray()}}function qe(i,r={}){const{thresholdValue:e=1e-9,thresholdError:t=1e-9}=r;i=v.checkMatrix(i);let s=i.rows,o=new v(s,s);for(let n=0;n<s;n++){let l=v.columnVector(i.getRow(n)),h=i.subMatrixRow(De(s,n)).transpose(),g=new pt(h).solve(l),f=v.sub(l,h.mmul(g)).abs().max();o.setRow(n,Le(f,g,n,e,t))}return o}function Fe(i,r=Number.EPSILON){if(i=v.checkMatrix(i),i.isEmpty())return i.transpose();let e=new pt(i,{autoTranspose:!0}),t=e.leftSingularVectors,s=e.rightSingularVectors,o=e.diagonal;for(let n=0;n<o.length;n++)Math.abs(o[n])>r?o[n]=1/o[n]:o[n]=0;return s.mmul(v.diag(o).mmul(t.transpose()))}function $e(i,r=i,e={}){i=new v(i);let t=!1;if(typeof r=="object"&&!v.isMatrix(r)&&!M.isAnyArray(r)?(e=r,r=i,t=!0):r=new v(r),i.rows!==r.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:s=!0}=e;s&&(i=i.center("column"),t||(r=r.center("column")));const o=i.transpose().mmul(r);for(let n=0;n<o.rows;n++)for(let l=0;l<o.columns;l++)o.set(n,l,o.get(n,l)*(1/(i.rows-1)));return o}function Ce(i,r=i,e={}){i=new v(i);let t=!1;if(typeof r=="object"&&!v.isMatrix(r)&&!M.isAnyArray(r)?(e=r,r=i,t=!0):r=new v(r),i.rows!==r.rows)throw new TypeError("Both matrices must have the same number of rows");const{center:s=!0,scale:o=!0}=e;s&&(i.center("column"),t||r.center("column")),o&&(i.scale("column"),t||r.scale("column"));const n=i.standardDeviation("column",{unbiased:!0}),l=t?n:r.standardDeviation("column",{unbiased:!0}),h=i.transpose().mmul(r);for(let u=0;u<h.rows;u++)for(let g=0;g<h.columns;g++)h.set(u,g,h.get(u,g)*(1/(n[u]*l[g]))*(1/(i.rows-1)));return h}class Jt{constructor(r,e={}){const{assumeSymmetric:t=!1}=e;if(r=st.checkMatrix(r),!r.isSquare())throw new Error("Matrix is not a square matrix");if(r.isEmpty())throw new Error("Matrix must be non-empty");let s=r.columns,o=new v(s,s),n=new Float64Array(s),l=new Float64Array(s),h=r,u,g,f=!1;if(t?f=!0:f=r.isSymmetric(),f){for(u=0;u<s;u++)for(g=0;g<s;g++)o.set(u,g,h.get(u,g));Ve(s,l,n,o),ze(s,l,n,o)}else{let p=new v(s,s),k=new Float64Array(s);for(g=0;g<s;g++)for(u=0;u<s;u++)p.set(u,g,h.get(u,g));Pe(s,p,k,o),Oe(s,l,n,o,p)}this.n=s,this.e=l,this.d=n,this.V=o}get realEigenvalues(){return Array.from(this.d)}get imaginaryEigenvalues(){return Array.from(this.e)}get eigenvectorMatrix(){return this.V}get diagonalMatrix(){let r=this.n,e=this.e,t=this.d,s=new v(r,r),o,n;for(o=0;o<r;o++){for(n=0;n<r;n++)s.set(o,n,0);s.set(o,o,t[o]),e[o]>0?s.set(o,o+1,e[o]):e[o]<0&&s.set(o,o-1,e[o])}return s}}function Ve(i,r,e,t){let s,o,n,l,h,u,g,f;for(h=0;h<i;h++)e[h]=t.get(i-1,h);for(l=i-1;l>0;l--){for(f=0,n=0,u=0;u<l;u++)f=f+Math.abs(e[u]);if(f===0)for(r[l]=e[l-1],h=0;h<l;h++)e[h]=t.get(l-1,h),t.set(l,h,0),t.set(h,l,0);else{for(u=0;u<l;u++)e[u]/=f,n+=e[u]*e[u];for(s=e[l-1],o=Math.sqrt(n),s>0&&(o=-o),r[l]=f*o,n=n-s*o,e[l-1]=s-o,h=0;h<l;h++)r[h]=0;for(h=0;h<l;h++){for(s=e[h],t.set(h,l,s),o=r[h]+t.get(h,h)*s,u=h+1;u<=l-1;u++)o+=t.get(u,h)*e[u],r[u]+=t.get(u,h)*s;r[h]=o}for(s=0,h=0;h<l;h++)r[h]/=n,s+=r[h]*e[h];for(g=s/(n+n),h=0;h<l;h++)r[h]-=g*e[h];for(h=0;h<l;h++){for(s=e[h],o=r[h],u=h;u<=l-1;u++)t.set(u,h,t.get(u,h)-(s*r[u]+o*e[u]));e[h]=t.get(l-1,h),t.set(l,h,0)}}e[l]=n}for(l=0;l<i-1;l++){if(t.set(i-1,l,t.get(l,l)),t.set(l,l,1),n=e[l+1],n!==0){for(u=0;u<=l;u++)e[u]=t.get(u,l+1)/n;for(h=0;h<=l;h++){for(o=0,u=0;u<=l;u++)o+=t.get(u,l+1)*t.get(u,h);for(u=0;u<=l;u++)t.set(u,h,t.get(u,h)-o*e[u])}}for(u=0;u<=l;u++)t.set(u,l+1,0)}for(h=0;h<i;h++)e[h]=t.get(i-1,h),t.set(i-1,h,0);t.set(i-1,i-1,1),r[0]=0}function ze(i,r,e,t){let s,o,n,l,h,u,g,f,p,k,w,y,R,a,j,T;for(n=1;n<i;n++)r[n-1]=r[n];r[i-1]=0;let C=0,V=0,Q=Number.EPSILON;for(u=0;u<i;u++){for(V=Math.max(V,Math.abs(e[u])+Math.abs(r[u])),g=u;g<i&&!(Math.abs(r[g])<=Q*V);)g++;if(g>u)do{for(s=e[u],f=(e[u+1]-s)/(2*r[u]),p=ft(f,1),f<0&&(p=-p),e[u]=r[u]/(f+p),e[u+1]=r[u]*(f+p),k=e[u+1],o=s-e[u],n=u+2;n<i;n++)e[n]-=o;for(C=C+o,f=e[g],w=1,y=w,R=w,a=r[u+1],j=0,T=0,n=g-1;n>=u;n--)for(R=y,y=w,T=j,s=w*r[n],o=w*f,p=ft(f,r[n]),r[n+1]=j*p,j=r[n]/p,w=f/p,f=w*e[n]-j*s,e[n+1]=o+j*(w*s+j*e[n]),h=0;h<i;h++)o=t.get(h,n+1),t.set(h,n+1,j*t.get(h,n)+w*o),t.set(h,n,w*t.get(h,n)-j*o);f=-j*T*R*a*r[u]/k,r[u]=j*f,e[u]=w*f}while(Math.abs(r[u])>Q*V);e[u]=e[u]+C,r[u]=0}for(n=0;n<i-1;n++){for(h=n,f=e[n],l=n+1;l<i;l++)e[l]<f&&(h=l,f=e[l]);if(h!==n)for(e[h]=e[n],e[n]=f,l=0;l<i;l++)f=t.get(l,n),t.set(l,n,t.get(l,h)),t.set(l,h,f)}}function Pe(i,r,e,t){let s=0,o=i-1,n,l,h,u,g,f,p;for(f=s+1;f<=o-1;f++){for(p=0,u=f;u<=o;u++)p=p+Math.abs(r.get(u,f-1));if(p!==0){for(h=0,u=o;u>=f;u--)e[u]=r.get(u,f-1)/p,h+=e[u]*e[u];for(l=Math.sqrt(h),e[f]>0&&(l=-l),h=h-e[f]*l,e[f]=e[f]-l,g=f;g<i;g++){for(n=0,u=o;u>=f;u--)n+=e[u]*r.get(u,g);for(n=n/h,u=f;u<=o;u++)r.set(u,g,r.get(u,g)-n*e[u])}for(u=0;u<=o;u++){for(n=0,g=o;g>=f;g--)n+=e[g]*r.get(u,g);for(n=n/h,g=f;g<=o;g++)r.set(u,g,r.get(u,g)-n*e[g])}e[f]=p*e[f],r.set(f,f-1,p*l)}}for(u=0;u<i;u++)for(g=0;g<i;g++)t.set(u,g,u===g?1:0);for(f=o-1;f>=s+1;f--)if(r.get(f,f-1)!==0){for(u=f+1;u<=o;u++)e[u]=r.get(u,f-1);for(g=f;g<=o;g++){for(l=0,u=f;u<=o;u++)l+=e[u]*t.get(u,g);for(l=l/e[f]/r.get(f,f-1),u=f;u<=o;u++)t.set(u,g,t.get(u,g)+l*e[u])}}}function Oe(i,r,e,t,s){let o=i-1,n=0,l=i-1,h=Number.EPSILON,u=0,g=0,f=0,p=0,k=0,w=0,y=0,R=0,a,j,T,C,V,Q,L,q,B,c,S,I,E,W,Y;for(a=0;a<i;a++)for((a<n||a>l)&&(e[a]=s.get(a,a),r[a]=0),j=Math.max(a-1,0);j<i;j++)g=g+Math.abs(s.get(a,j));for(;o>=n;){for(C=o;C>n&&(w=Math.abs(s.get(C-1,C-1))+Math.abs(s.get(C,C)),w===0&&(w=g),!(Math.abs(s.get(C,C-1))<h*w));)C--;if(C===o)s.set(o,o,s.get(o,o)+u),e[o]=s.get(o,o),r[o]=0,o--,R=0;else if(C===o-1){if(L=s.get(o,o-1)*s.get(o-1,o),f=(s.get(o-1,o-1)-s.get(o,o))/2,p=f*f+L,y=Math.sqrt(Math.abs(p)),s.set(o,o,s.get(o,o)+u),s.set(o-1,o-1,s.get(o-1,o-1)+u),q=s.get(o,o),p>=0){for(y=f>=0?f+y:f-y,e[o-1]=q+y,e[o]=e[o-1],y!==0&&(e[o]=q-L/y),r[o-1]=0,r[o]=0,q=s.get(o,o-1),w=Math.abs(q)+Math.abs(y),f=q/w,p=y/w,k=Math.sqrt(f*f+p*p),f=f/k,p=p/k,j=o-1;j<i;j++)y=s.get(o-1,j),s.set(o-1,j,p*y+f*s.get(o,j)),s.set(o,j,p*s.get(o,j)-f*y);for(a=0;a<=o;a++)y=s.get(a,o-1),s.set(a,o-1,p*y+f*s.get(a,o)),s.set(a,o,p*s.get(a,o)-f*y);for(a=n;a<=l;a++)y=t.get(a,o-1),t.set(a,o-1,p*y+f*t.get(a,o)),t.set(a,o,p*t.get(a,o)-f*y)}else e[o-1]=q+f,e[o]=q+f,r[o-1]=y,r[o]=-y;o=o-2,R=0}else{if(q=s.get(o,o),B=0,L=0,C<o&&(B=s.get(o-1,o-1),L=s.get(o,o-1)*s.get(o-1,o)),R===10){for(u+=q,a=n;a<=o;a++)s.set(a,a,s.get(a,a)-q);w=Math.abs(s.get(o,o-1))+Math.abs(s.get(o-1,o-2)),q=B=.75*w,L=-.4375*w*w}if(R===30&&(w=(B-q)/2,w=w*w+L,w>0)){for(w=Math.sqrt(w),B<q&&(w=-w),w=q-L/((B-q)/2+w),a=n;a<=o;a++)s.set(a,a,s.get(a,a)-w);u+=w,q=B=L=.964}for(R=R+1,V=o-2;V>=C&&(y=s.get(V,V),k=q-y,w=B-y,f=(k*w-L)/s.get(V+1,V)+s.get(V,V+1),p=s.get(V+1,V+1)-y-k-w,k=s.get(V+2,V+1),w=Math.abs(f)+Math.abs(p)+Math.abs(k),f=f/w,p=p/w,k=k/w,!(V===C||Math.abs(s.get(V,V-1))*(Math.abs(p)+Math.abs(k))<h*(Math.abs(f)*(Math.abs(s.get(V-1,V-1))+Math.abs(y)+Math.abs(s.get(V+1,V+1))))));)V--;for(a=V+2;a<=o;a++)s.set(a,a-2,0),a>V+2&&s.set(a,a-3,0);for(T=V;T<=o-1&&(W=T!==o-1,T!==V&&(f=s.get(T,T-1),p=s.get(T+1,T-1),k=W?s.get(T+2,T-1):0,q=Math.abs(f)+Math.abs(p)+Math.abs(k),q!==0&&(f=f/q,p=p/q,k=k/q)),q!==0);T++)if(w=Math.sqrt(f*f+p*p+k*k),f<0&&(w=-w),w!==0){for(T!==V?s.set(T,T-1,-w*q):C!==V&&s.set(T,T-1,-s.get(T,T-1)),f=f+w,q=f/w,B=p/w,y=k/w,p=p/f,k=k/f,j=T;j<i;j++)f=s.get(T,j)+p*s.get(T+1,j),W&&(f=f+k*s.get(T+2,j),s.set(T+2,j,s.get(T+2,j)-f*y)),s.set(T,j,s.get(T,j)-f*q),s.set(T+1,j,s.get(T+1,j)-f*B);for(a=0;a<=Math.min(o,T+3);a++)f=q*s.get(a,T)+B*s.get(a,T+1),W&&(f=f+y*s.get(a,T+2),s.set(a,T+2,s.get(a,T+2)-f*k)),s.set(a,T,s.get(a,T)-f),s.set(a,T+1,s.get(a,T+1)-f*p);for(a=n;a<=l;a++)f=q*t.get(a,T)+B*t.get(a,T+1),W&&(f=f+y*t.get(a,T+2),t.set(a,T+2,t.get(a,T+2)-f*k)),t.set(a,T,t.get(a,T)-f),t.set(a,T+1,t.get(a,T+1)-f*p)}}}if(g!==0){for(o=i-1;o>=0;o--)if(f=e[o],p=r[o],p===0)for(C=o,s.set(o,o,1),a=o-1;a>=0;a--){for(L=s.get(a,a)-f,k=0,j=C;j<=o;j++)k=k+s.get(a,j)*s.get(j,o);if(r[a]<0)y=L,w=k;else if(C=a,r[a]===0?s.set(a,o,L!==0?-k/L:-k/(h*g)):(q=s.get(a,a+1),B=s.get(a+1,a),p=(e[a]-f)*(e[a]-f)+r[a]*r[a],Q=(q*w-y*k)/p,s.set(a,o,Q),s.set(a+1,o,Math.abs(q)>Math.abs(y)?(-k-L*Q)/q:(-w-B*Q)/y)),Q=Math.abs(s.get(a,o)),h*Q*Q>1)for(j=a;j<=o;j++)s.set(j,o,s.get(j,o)/Q)}else if(p<0)for(C=o-1,Math.abs(s.get(o,o-1))>Math.abs(s.get(o-1,o))?(s.set(o-1,o-1,p/s.get(o,o-1)),s.set(o-1,o,-(s.get(o,o)-f)/s.get(o,o-1))):(Y=It(0,-s.get(o-1,o),s.get(o-1,o-1)-f,p),s.set(o-1,o-1,Y[0]),s.set(o-1,o,Y[1])),s.set(o,o-1,0),s.set(o,o,1),a=o-2;a>=0;a--){for(c=0,S=0,j=C;j<=o;j++)c=c+s.get(a,j)*s.get(j,o-1),S=S+s.get(a,j)*s.get(j,o);if(L=s.get(a,a)-f,r[a]<0)y=L,k=c,w=S;else if(C=a,r[a]===0?(Y=It(-c,-S,L,p),s.set(a,o-1,Y[0]),s.set(a,o,Y[1])):(q=s.get(a,a+1),B=s.get(a+1,a),I=(e[a]-f)*(e[a]-f)+r[a]*r[a]-p*p,E=(e[a]-f)*2*p,I===0&&E===0&&(I=h*g*(Math.abs(L)+Math.abs(p)+Math.abs(q)+Math.abs(B)+Math.abs(y))),Y=It(q*k-y*c+p*S,q*w-y*S-p*c,I,E),s.set(a,o-1,Y[0]),s.set(a,o,Y[1]),Math.abs(q)>Math.abs(y)+Math.abs(p)?(s.set(a+1,o-1,(-c-L*s.get(a,o-1)+p*s.get(a,o))/q),s.set(a+1,o,(-S-L*s.get(a,o)-p*s.get(a,o-1))/q)):(Y=It(-k-B*s.get(a,o-1),-w-B*s.get(a,o),y,p),s.set(a+1,o-1,Y[0]),s.set(a+1,o,Y[1]))),Q=Math.max(Math.abs(s.get(a,o-1)),Math.abs(s.get(a,o))),h*Q*Q>1)for(j=a;j<=o;j++)s.set(j,o-1,s.get(j,o-1)/Q),s.set(j,o,s.get(j,o)/Q)}for(a=0;a<i;a++)if(a<n||a>l)for(j=a;j<i;j++)t.set(a,j,s.get(a,j));for(j=i-1;j>=n;j--)for(a=n;a<=l;a++){for(y=0,T=n;T<=Math.min(j,l);T++)y=y+t.get(a,T)*s.get(T,j);t.set(a,j,y)}}}function It(i,r,e,t){let s,o;return Math.abs(e)>Math.abs(t)?(s=t/e,o=e+s*t,[(i+s*r)/o,(r-s*i)/o]):(s=e/t,o=t+s*e,[(s*i+r)/o,(s*r-i)/o])}class Qt{constructor(r){if(r=st.checkMatrix(r),!r.isSymmetric())throw new Error("Matrix is not symmetric");let e=r,t=e.rows,s=new v(t,t),o=!0,n,l,h;for(l=0;l<t;l++){let u=0;for(h=0;h<l;h++){let g=0;for(n=0;n<h;n++)g+=s.get(h,n)*s.get(l,n);g=(e.get(l,h)-g)/s.get(h,h),s.set(l,h,g),u=u+g*g}for(u=e.get(l,l)-u,o&&(o=u>0),s.set(l,l,Math.sqrt(Math.max(u,0))),h=l+1;h<t;h++)s.set(l,h,0)}this.L=s,this.positiveDefinite=o}isPositiveDefinite(){return this.positiveDefinite}solve(r){r=st.checkMatrix(r);let e=this.L,t=e.rows;if(r.rows!==t)throw new Error("Matrix dimensions do not match");if(this.isPositiveDefinite()===!1)throw new Error("Matrix is not positive definite");let s=r.columns,o=r.clone(),n,l,h;for(h=0;h<t;h++)for(l=0;l<s;l++){for(n=0;n<h;n++)o.set(h,l,o.get(h,l)-o.get(n,l)*e.get(h,n));o.set(h,l,o.get(h,l)/e.get(h,h))}for(h=t-1;h>=0;h--)for(l=0;l<s;l++){for(n=h+1;n<t;n++)o.set(h,l,o.get(h,l)-o.get(n,l)*e.get(n,h));o.set(h,l,o.get(h,l)/e.get(h,h))}return o}get lowerTriangularMatrix(){return this.L}}class Wt{constructor(r,e={}){r=st.checkMatrix(r);let{Y:t}=e;const{scaleScores:s=!1,maxIterations:o=1e3,terminationCriteria:n=1e-10}=e;let l;if(t){if(M.isAnyArray(t)&&typeof t[0]=="number"?t=v.columnVector(t):t=st.checkMatrix(t),t.rows!==r.rows)throw new Error("Y should have the same number of rows as X");l=t.getColumnVector(0)}else l=r.getColumnVector(0);let h=1,u,g,f,p;for(let k=0;k<o&&h>n;k++)f=r.transpose().mmul(l).div(l.transpose().mmul(l).get(0,0)),f=f.div(f.norm()),u=r.mmul(f).div(f.transpose().mmul(f).get(0,0)),k>0&&(h=u.clone().sub(p).pow(2).sum()),p=u.clone(),t?(g=t.transpose().mmul(u).div(u.transpose().mmul(u).get(0,0)),g=g.div(g.norm()),l=t.mmul(g).div(g.transpose().mmul(g).get(0,0))):l=u;if(t){let k=r.transpose().mmul(u).div(u.transpose().mmul(u).get(0,0));k=k.div(k.norm());let w=r.clone().sub(u.clone().mmul(k.transpose())),y=l.transpose().mmul(u).div(u.transpose().mmul(u).get(0,0)),R=t.clone().sub(u.clone().mulS(y.get(0,0)).mmul(g.transpose()));this.t=u,this.p=k.transpose(),this.w=f.transpose(),this.q=g,this.u=l,this.s=u.transpose().mmul(u),this.xResidual=w,this.yResidual=R,this.betas=y}else this.w=f.transpose(),this.s=u.transpose().mmul(u).sqrt(),s?this.t=u.clone().div(this.s.get(0,0)):this.t=u,this.xResidual=r.sub(u.mmul(f.transpose()))}}return P.AbstractMatrix=z,P.CHO=Qt,P.CholeskyDecomposition=Qt,P.DistanceMatrix=jt,P.EVD=Jt,P.EigenvalueDecomposition=Jt,P.LU=vt,P.LuDecomposition=vt,P.Matrix=v,P.MatrixColumnSelectionView=be,P.MatrixColumnView=Se,P.MatrixFlipColumnView=Ee,P.MatrixFlipRowView=je,P.MatrixRowSelectionView=ve,P.MatrixRowView=ke,P.MatrixSelectionView=kt,P.MatrixSubView=Re,P.MatrixTransposeView=Ie,P.NIPALS=Wt,P.Nipals=Wt,P.QR=Ct,P.QrDecomposition=Ct,P.SVD=pt,P.SingularValueDecomposition=pt,P.SymmetricMatrix=gt,P.WrapperMatrix1D=Bt,P.WrapperMatrix2D=st,P.correlation=Ce,P.covariance=$e,P.default=v,P.determinant=Rt,P.inverse=Ne,P.linearDependencies=qe,P.pseudoInverse=Fe,P.solve=Gt,P.wrap=Te,P}var Ut=ns();const Zt=xe(Ut),yt=Ut.Matrix;Zt.Matrix?Zt.Matrix:Ut.Matrix;function ls(M){if(!Mt(M))throw new TypeError("input must be an array");if(M.length===0)throw new TypeError("input must not be empty");for(var m=0,d=0;d<M.length;d++)m+=M[d];return m}function At(M){return ls(M)/M.length}function Ht(M,m){let d=new Array(m).fill(0);for(let b=0;b<M.length;++b)d[M[b]]+=1/M.length;return yt.rowVector(d)}function _t(M){if(M.length===0)return 0;let m=Ht(M,te(M)).getRow(0),d=0;for(let b=0;b<m.length;++b)d+=m[b]*m[b];return 1-d}function te(M){return M.filter((m,d,b)=>b.indexOf(m)===d).map(m=>m+1).reduce((m,d)=>Math.max(m,d))}function hs(M,m){let d=0,b=["greater","lesser"];for(let D=0;D<b.length;++D){let N=m[b[D]];d+=_t(N)*N.length/M.length}return _t(M)-d}function us(M){let m=M.length;if(m===0)return 0;let d=At(M),b=0;for(let D=0;D<m;++D){let N=M[D];b+=(N-d)*(N-d)}return b}function fs(M,m){let d=0,b=["greater","lesser"];for(let D=0;D<b.length;++D){let N=m[b[D]];d+=us(N)}return d}function as(M,m,d,b){let D=[],N=[],F=[],$=[];for(let U=0;U<M.rows;++U)M.get(U,d)<b?(D.push(M.getRow(U)),F.push(m[U])):(N.push(M.getRow(U)),$.push(m[U]));return{greaterX:N,greaterY:$,lesserX:D,lesserY:F}}function cs(M,m){return(M+m)/2}function gs(M,m){if(M.length!==m.length)throw new TypeError(`Error on zip: the size of a: ${M.length} is different from b: ${m.length}`);let d=new Array(M.length);for(let b=0;b<M.length;++b)d[b]=[M[b],m[b]];return d}const ms={gini:hs,regression:fs},ws={mean:cs};class mt{constructor(m){this.kind=m.kind,this.gainFunction=m.gainFunction,this.splitFunction=m.splitFunction,this.minNumSamples=m.minNumSamples,this.maxDepth=m.maxDepth,this.gainThreshold=m.gainThreshold||0}bestSplit(m,d){let b=this.kind==="classifier"?-1/0:1/0,D=this.kind==="classifier"?(U,K)=>U>K:(U,K)=>U<K,N,F,$;for(let U=0;U<m.rows;++U){let K=m.getRow(U),G=this.featureSplit(K,d);for(let Z=0;Z<G.length;++Z){let et=G[Z],lt=this.split(K,d,et),ct=ms[this.gainFunction](d,lt);D(ct,b)&&(N=U,F=et,b=ct,$=K.length)}}return{maxGain:b,maxColumn:N,maxValue:F,numberSamples:$}}split(m,d,b){let D=[],N=[];for(let F=0;F<m.length;++F)m[F]<b?D.push(d[F]):N.push(d[F]);return{greater:N,lesser:D}}featureSplit(m,d){let b=[],D=gs(m,d);D.sort((N,F)=>N[0]-F[0]);for(let N=1;N<D.length;++N)D[N-1][1]!==D[N][1]&&b.push(ws[this.splitFunction](D[N-1][0],D[N][0]));return b}calculatePrediction(m){if(this.kind==="classifier"){if(this.distribution=Ht(m,te(m)),this.distribution.columns===0)throw new TypeError("Error on calculate the prediction")}else this.distribution=At(m)}train(m,d,b,D){if(m.rows<=this.minNumSamples){this.calculatePrediction(d);return}D===void 0&&(D=0);let N=m.transpose(),F=this.bestSplit(N,d);this.splitValue=F.maxValue,this.splitColumn=F.maxColumn,this.gain=F.maxGain,this.numberSamples=F.numberSamples;let $=as(m,d,this.splitColumn,this.splitValue);if(b<this.maxDepth&&this.gain>this.gainThreshold&&this.gain!==D&&$.lesserX.length>0&&$.greaterX.length>0){this.left=new mt(this),this.right=new mt(this);let U=new yt($.lesserX),K=new yt($.greaterX);this.left.train(U,$.lesserY,b+1,this.gain),this.right.train(K,$.greaterY,b+1,this.gain)}else this.calculatePrediction(d)}classify(m){return this.right&&this.left?m[this.splitColumn]<this.splitValue?this.left.classify(m):this.right.classify(m):this.distribution}setNodeParameters(m){m.distribution!==void 0?this.distribution=m.distribution.constructor===Array?new yt(m.distribution):m.distribution:(this.distribution=void 0,this.splitValue=m.splitValue,this.splitColumn=m.splitColumn,this.gain=m.gain,this.left=new mt(this),this.right=new mt(this),m.left!=={}&&this.left.setNodeParameters(m.left),m.right!=={}&&this.right.setNodeParameters(m.right))}}const ps={gainFunction:"gini",splitFunction:"mean",minNumSamples:3,maxDepth:1/0,gainThreshold:.01};class qt{constructor(m,d){m===!0?(this.options=d.options,this.root=new mt(d.options),this.root.setNodeParameters(d.root)):(this.options=Object.assign({},ps,m),this.options.kind="classifier")}train(m,d){this.root=new mt(this.options),m=yt.checkMatrix(m),this.root.train(m,d,0,null)}predict(m){m=yt.checkMatrix(m);let d=new Array(m.rows);for(let b=0;b<m.rows;++b)d[b]=this.root.classify(m.getRow(b)).maxRowIndex(0)[1];return d}toJSON(){return{options:this.options,root:this.root,name:"DTClassifier"}}static load(m){if(m.name!=="DTClassifier")throw new RangeError(`Invalid model: ${m.name}`);return new qt(!0,m)}}class Ms{constructor(){dt(this,"trainingData",null);dt(this,"splitData",{trainFeatures:[],trainLabelsY:[],testFeatures:[],testLabelsY:[]});dt(this,"treeModel",null);dt(this,"states",{dataLoading:{isLoading:!1,error:null},modelLoading:{isLoading:!1,error:null},training:{isLoading:!1,error:null},evaluation:{isLoading:!1,error:null},prediction:{isLoading:!1,error:null},saving:{isLoading:!1,error:null}})}getTrainingData(){return this.trainingData}getSplitData(){return this.splitData}getTreeModel(){return this.treeModel}getTreeModelJson(){var m;return(m=this.treeModel)==null?void 0:m.toJSON()}getDataLoadingState(){return this.states.dataLoading}getModelLoadingState(){return this.states.modelLoading}getTrainingState(){return this.states.training}getEvaluationState(){return this.states.evaluation}getPredictionState(){return this.states.prediction}getSavingState(){return this.states.saving}setState(m,d){this.states[m]={...this.states[m],...d}}resetState(m){this.states[m]={isLoading:!1,error:null,data:void 0}}async fetchAndProcessData(){var m;this.setState("dataLoading",{isLoading:!0,error:null});try{const d=await Lt.get(route("api.DecisionTree.getData"));if(d.status!==200)throw new Error(`API returned status ${d.status}`);const b=d.data,D=(b==null?void 0:b.training)??[],N=(b==null?void 0:b.kriteria)??[],F=(b==null?void 0:b.label)??[];if(D.length===0||N.length===0)throw new Error("Data training atau kriteria dari API kosong");const $=[],U=[];for(const G of D){const Z=G.slice(0,-1).map(Number);$.push(Z);const et=G[G.length-1],lt=((m=F.find(ct=>ct.nama===et))==null?void 0:m.id)||0;U.push(lt)}const K={features:$,labelsY:U,featureNames:N.slice(0,-1),label:F};return this.trainingData=K,this.splitData=this.splitDataTraining($,U,.8),this.setState("dataLoading",{isLoading:!1,data:K}),K}catch(d){const b="Gagal memuat dataset: "+d.message;throw this.setState("dataLoading",{isLoading:!1,error:b}),new Error(b)}}splitDataTraining(m,d,b=.7){const D=m.map((F,$)=>$).sort(()=>Math.random()-.5),N=Math.floor(m.length*b);return{trainFeatures:D.slice(0,N).map(F=>m[F]),trainLabelsY:D.slice(0,N).map(F=>d[F]),testFeatures:D.slice(N).map(F=>m[F]),testLabelsY:D.slice(N).map(F=>d[F])}}async loadModel(){this.setState("modelLoading",{isLoading:!0,error:null});try{const m=await Lt.get(route("DecisionTree.getModel"));if(m.status!==200)throw new Error(`API returned status ${m.status}`);const d=JSON.parse(m.data.model);return this.treeModel=qt.load(d),this.setState("modelLoading",{isLoading:!1,data:this.treeModel}),this.treeModel}catch(m){const d="Gagal memuat model: "+m.message;throw this.setState("modelLoading",{isLoading:!1,error:d}),new Error(d)}}async trainModel(m){this.setState("training",{isLoading:!0,error:null});try{if(!this.trainingData||this.trainingData.features.length===0)throw new Error("Training data tidak tersedia atau kosong");const d={gainFunction:"gini",maxDepth:3,minNumSamples:1,...m},b=new qt(d);b.train(this.trainingData.features,this.trainingData.labelsY),this.treeModel=b,this.setState("training",{isLoading:!1})}catch(d){const b="Gagal melatih model: "+d.message;throw this.setState("training",{isLoading:!1,error:b}),new Error(b)}}async evaluateModel(){this.setState("evaluation",{isLoading:!0,error:null});try{if(!this.treeModel||!this.splitData)throw new Error("Model atau data split tidak tersedia");const m=this.treeModel.predict(this.splitData.testFeatures),d=[...new Set(this.splitData.testLabelsY)].sort(($,U)=>$-U);let b=0;for(let $=0;$<m.length;$++)m[$]===this.splitData.testLabelsY[$]&&b++;const D=b/m.length,N=d.map(()=>d.map(()=>0));for(let $=0;$<m.length;$++){const U=d.indexOf(this.splitData.testLabelsY[$]),K=d.indexOf(m[$]);N[U][K]++}const F={accuracy:D,confusionMatrix:N};return this.setState("evaluation",{isLoading:!1,data:F}),F}catch(m){const d="Gagal mengevaluasi model: "+m.message;throw this.setState("evaluation",{isLoading:!1,error:d}),new Error(d)}}async getsayuran(m){let d=null;try{const b=await Lt.get(route("api.get.sayuran")),D=b.data;b.status==200&&(d=D.filter(N=>N.nama.toLowerCase()==m.toLowerCase())[0].deskripsi)}catch(b){console.log("Terjadi kesalahan ketika memuat data sayuran :",b)}return{rekomendasi:d??""}}async predict(m){var d,b;this.setState("prediction",{isLoading:!0,error:null});try{if(!this.treeModel)throw new Error("Model belum dimuat");if(!this.trainingData)throw new Error("Data training tidak tersedia");const D=Array.isArray(m[0])?m:[m];if(D[0].length!==((d=this.trainingData.features[0])==null?void 0:d.length))throw new Error(`Jumlah fitur tidak sesuai. Diharapkan: ${(b=this.trainingData.features[0])==null?void 0:b.length}`);const N=this.treeModel.predict(D),F=N.map(G=>{var Z;return((Z=this.trainingData.label.find(et=>et.id===G))==null?void 0:Z.nama)||"Unknown"}),$=F.length===1?F[0]:F,U=await this.getsayuran($),K={prediction:N.length===1?N[0]:N,label:$,rekomendasi:U.rekomendasi,error:null};return this.setState("prediction",{isLoading:!1,data:K}),K}catch(D){const N="Prediksi gagal: "+D.message;throw this.setState("prediction",{isLoading:!1,error:N}),new Error(N)}}async saveModel(){this.setState("saving",{isLoading:!0,error:null});try{if(!this.treeModel)throw new Error("Tidak ada model yang tersedia untuk disimpan");const m=await Lt.post(route("DecisionTree.store"),{model:JSON.stringify(this.treeModel)});if(m.status!==200)throw new Error(`Gagal menyimpan model: ${m.statusText}`);this.setState("saving",{isLoading:!1})}catch(m){const d="Gagal menyimpan model: "+m.message;throw this.setState("saving",{isLoading:!1,error:d}),new Error(d)}}}export{Ms as D};
